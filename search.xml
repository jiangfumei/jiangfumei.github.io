<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring源码</title>
    <url>/2020/12/04/Spring%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2020/11/26/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程基础">线程基础</h2>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql数据库编码</title>
    <url>/2020/07/06/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>上传到七牛云的视频播放地址链接存到数据库的url地址汉字部分有空格从而导致客户端不能播放视频地址，因为上传前没有对上传文件统一命名，为避免此情况再发生，事后我对上传文件以uuid命名。但是，那些已经传完的视频数据大约有一百多条，我如何对其编码成和七牛云一样的编码地址呢？这就开始接触到了数据库url编码。</p>
<a id="more"></a>
<h2 id="解决过程">解决过程</h2>
<ol>
<li>先对数据库统一编码，参考文章<a href="https://blog.csdn.net/weixin_33831673/article/details/91822470" target="_blank" rel="noopener">mysql urlencode 支持中文</a>,在此也贴上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER ;</span><br><span class="line"> </span><br><span class="line">DROP FUNCTION IF EXISTS urlencode;</span><br><span class="line"> </span><br><span class="line">DELIMITER |</span><br><span class="line"> </span><br><span class="line">CREATE FUNCTION URLENCODE(str VARCHAR(4096) CHARSET utf8) RETURNS VARCHAR(4096) CHARSET utf8</span><br><span class="line">DETERMINISTIC</span><br><span class="line">CONTAINS SQL</span><br><span class="line">BEGIN</span><br><span class="line">   -- the individual character we are converting in our loop</span><br><span class="line">   -- NOTE: must be VARCHAR even though it won&#39;t vary in length</span><br><span class="line">   -- CHAR(1), when used with SUBSTRING, made spaces &#39;&#39; instead of &#39; &#39;</span><br><span class="line">   DECLARE sub VARCHAR(1) CHARSET utf8;</span><br><span class="line">   -- the ordinal value of the character (i.e. ñ becomes 50097)</span><br><span class="line">   DECLARE val BIGINT DEFAULT 0;</span><br><span class="line">   -- the substring index we use in our loop (one-based)</span><br><span class="line">   DECLARE ind INT DEFAULT 1;</span><br><span class="line">   -- the integer value of the individual octet of a character being encoded</span><br><span class="line">   -- (which is potentially multi-byte and must be encoded one byte at a time)</span><br><span class="line">   DECLARE OCT INT DEFAULT 0;</span><br><span class="line">   -- the encoded return string that we build up during execution</span><br><span class="line">   DECLARE ret VARCHAR(4096) DEFAULT &#39;&#39;;</span><br><span class="line">   -- our loop index for looping through each octet while encoding</span><br><span class="line">   DECLARE octind INT DEFAULT 0;</span><br><span class="line"> </span><br><span class="line">   IF ISNULL(str) THEN</span><br><span class="line">      RETURN NULL;</span><br><span class="line">   ELSE</span><br><span class="line">      SET ret &#x3D; &#39;&#39;;</span><br><span class="line">      -- loop through the input string one character at a time - regardless</span><br><span class="line">      -- of how many bytes a character consists of</span><br><span class="line">      WHILE ind &lt;&#x3D; CHAR_LENGTH(str) DO</span><br><span class="line">         SET sub &#x3D; MID(str, ind, 1);</span><br><span class="line">         SET val &#x3D; ORD(sub);</span><br><span class="line">         -- these values are ones that should not be converted</span><br><span class="line">         -- see http:&#x2F;&#x2F;tools.ietf.org&#x2F;html&#x2F;rfc3986</span><br><span class="line">         IF NOT (val BETWEEN 48 AND 57 OR     -- 48-57  &#x3D; 0-9</span><br><span class="line">                 val BETWEEN 65 AND 90 OR     -- 65-90  &#x3D; A-Z</span><br><span class="line">                 val BETWEEN 97 AND 122 OR    -- 97-122 &#x3D; a-z</span><br><span class="line">                 -- 45 &#x3D; hyphen, 46 &#x3D; period, 95 &#x3D; underscore, 126 &#x3D; tilde</span><br><span class="line">                 val IN (45, 46, 95, 126)) THEN</span><br><span class="line">            -- This is not an &quot;unreserved&quot; char and must be encoded:</span><br><span class="line">            -- loop through each octet of the potentially multi-octet character</span><br><span class="line">            -- and convert each into its hexadecimal value</span><br><span class="line">            -- we start with the high octect because that is the order that ORD</span><br><span class="line">            -- returns them in - they need to be encoded with the most significant</span><br><span class="line">            -- byte first</span><br><span class="line">            SET octind &#x3D; OCTET_LENGTH(sub);</span><br><span class="line">            WHILE octind &gt; 0 DO</span><br><span class="line">               -- get the actual value of this octet by shifting it to the right</span><br><span class="line">               -- so that it is at the lowest byte position - in other words, make</span><br><span class="line">               -- the octet&#x2F;byte we are working on the entire number (or in even</span><br><span class="line">               -- other words, oct will no be between zero and 255 inclusive)</span><br><span class="line">               SET OCT &#x3D; (val &gt;&gt; (8 * (octind - 1)));</span><br><span class="line">               -- we append this to our return string with a percent sign, and then</span><br><span class="line">               -- a left-zero-padded (to two characters) string of the hexadecimal</span><br><span class="line">               -- value of this octet)</span><br><span class="line">               SET ret &#x3D; CONCAT(ret, &#39;%&#39;, LPAD(HEX(OCT), 2, 0));</span><br><span class="line">               -- now we need to reset val to essentially zero out the octet that we</span><br><span class="line">               -- just encoded so that our number decreases and we are only left with</span><br><span class="line">               -- the lower octets as part of our integer</span><br><span class="line">               SET val &#x3D; (val &amp; (POWER(256, (octind - 1)) - 1));</span><br><span class="line">               SET octind &#x3D; (octind - 1);</span><br><span class="line">            END WHILE;</span><br><span class="line">         ELSE</span><br><span class="line">            -- this character was not one that needed to be encoded and can simply be</span><br><span class="line">            -- added to our return string as-is</span><br><span class="line">            SET ret &#x3D; CONCAT(ret, sub);</span><br><span class="line">         END IF;</span><br><span class="line">         SET ind &#x3D; (ind + 1);</span><br><span class="line">      END WHILE;</span><br><span class="line">   END IF;</span><br><span class="line">   RETURN ret;</span><br><span class="line">END;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>运用sql函数操作库表<br>
使用<code>left</code>、<code>subString</code>、<code>truncate</code>等函数对数据库中的多条数据批量修改。</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql时区与Java项目的时区问题</title>
    <url>/2020/06/15/MySql%E6%97%B6%E5%8C%BA%E4%B8%8EJava%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>一日部署完项目postman测试，发现json返回结果的时间字段与数据库的时间相差了13个小时。马上进行了排查问题工作。</p>
<h2 id="排查问题">排查问题</h2>
<ol>
<li>查看mysql时区</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%time_zone%&quot;;</span><br><span class="line">+------------------+--------+</span><br><span class="line">| Variable_name   | Value  |</span><br><span class="line">+------------------+--------+</span><br><span class="line">| system_time_zone | CST   |</span><br><span class="line">| time_zone     | SYSTEM |</span><br><span class="line">+------------------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>发现数据库的是CST时区<br>
2. 因为我的项目和mysql都是docker容器装的，所以查看这两个docker 容器的时间显示<br>
<code>docker exec -it mysql /bin/bash</code><br>
<code>docker exec -it project /bin/bash</code><br>
进入容器后，<code>date</code>命令查看显示Mon Jun 15 11:19:13 CST 2020,都是CST,首先我们要明白CST时区的含义<br>
CST时区4种含义：<br>
. 美国中部时间 Central Standard Time (USA) UTC-06:00<br>
. 澳大利亚中部时间 Central Standard Time (Australia)<br>
. UTC+09:30 中国标准时 China Standard Time<br>
. UTC+08:00 古巴标准时 Cuba Standard Time UTC-04:00<br>
另外：美国从“3月11日”至“11月7日”实行夏令时，美国中部时间改为 UTC-05:00，与 UTC+08:00 相差 13 小时。<br>
这好像就查到原因了，接下来就是解决问题了。</p>
<h2 id="解决问题">解决问题</h2>
<p>法1. 配置文件my.cnf修改时区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##在[mysqld]</span><br><span class="line">default-time_zone &#x3D; &#39;+8:00&#39;</span><br></pre></td></tr></table></figure>
<p>重启mysql服务。检查，返回json结果时间与数据库一致。<br>
法2. 直接在application.yml配置文件中datasource后添加<br>
<code>useTimezone=true&amp;serverTimezone=GMT%2B8</code><br>
重新deploy一下，正确<br>
对比下来好像第二种方法较为简单，不用修改mysql配置文件。😄。</p>
<h2 id="总结">总结</h2>
<p>正常情况下，数据库表时间不受服务器及其它影响，存进去是多少取出来时间也是多少。唯一改变的因素就是在返回json结果时一般返回的时间是json字符串，这就需要加上所在的时区显示json格式，如东八区如下图：<br>
<img src="/images/config.png" alt="">,在遇到时区问题时具体问题应具体分析，此篇可做参考😄。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Sdk上传本地文件至七牛云</title>
    <url>/2020/06/05/js-sdk-qiniuyun/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>后台管理页面需要增加上传本地视频到七牛云功能。使用七牛云官方客户端(Web端)JavaScript sdk</p>
<h2 id="代码集成">代码集成</h2>
<p>前台js文件 uploadVideo.js</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;<span class="attr">url</span>: <span class="string">"/qiniu/upload/uptoken"</span>, <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> initFileInput(res)&#125;)<span class="comment">//请求后台接口获取上传token</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> initFileInput = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = res.uptoken;</span><br><span class="line">    <span class="keyword">let</span> domain = res.domain;</span><br><span class="line">    <span class="keyword">let</span> config = &#123;</span><br><span class="line">        useCdnDomain: <span class="literal">true</span>,</span><br><span class="line">        region: qiniu.region.as0</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> putExtra = &#123;</span><br><span class="line">        fname: <span class="string">""</span>,</span><br><span class="line">        params: &#123;&#125;,</span><br><span class="line">        mimeType: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    $(<span class="string">"#file1"</span>).change(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> file = <span class="keyword">this</span>.files[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> key = file.name;</span><br><span class="line">        <span class="comment">//获取当前时间</span></span><br><span class="line">        <span class="keyword">let</span> timestamp=<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">let</span> keyValue = <span class="string">'rizin/video/'</span> + timestamp + <span class="string">'/'</span> + key;</span><br><span class="line">        <span class="comment">// 添加上传dom面板</span></span><br><span class="line">        <span class="keyword">let</span> next = <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> total = response.total;</span><br><span class="line">            <span class="comment">/*$(".speed").text("进度：" + total.percent + "% ");*/</span></span><br><span class="line">            $(<span class="string">"#speed1"</span>).text(<span class="string">"进度："</span> + total.percent + <span class="string">"% "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置next,error,complete对应的操作，分别处理相应的进度信息，错误信息，以及完成后的操作</span></span><br><span class="line">        <span class="keyword">let</span> error = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">"上传出错"</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> complete = <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            sdDeal(res.key, domain);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> subObject = &#123;</span><br><span class="line">            next: next,</span><br><span class="line">            error: error,</span><br><span class="line">            complete: complete</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 调用sdk上传接口获得相应的observable，控制上传和暂停</span></span><br><span class="line">        <span class="keyword">let</span> observable = qiniu.upload(file, keyValue, token, putExtra, config);</span><br><span class="line">        <span class="comment">//observable.subscribe(next);</span></span><br><span class="line">        observable.subscribe(subObject);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>html文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">    &lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-sm-2 control-label"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span>*<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span>画質（普通）&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="col-sm-4"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="file" id="file1"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="hidden"  name="sd" id="sdhid" value=""&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-sm-2"</span> style=<span class="string">'overflow:hidden'</span>&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">'speed'</span> id=<span class="string">"speed1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>
<p>后台集成需要引入七牛云相关依赖，官方sdk都有<br>
application.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">###七牛云视频上传###</span><br><span class="line">qiniu.accessKey=**************************</span><br><span class="line">qiniu.secretKey=**************************</span><br><span class="line">qiniu.vhost=http:<span class="comment">//xxx.com/</span></span><br><span class="line">qiniu.zone=as0<span class="comment">//区域</span></span><br><span class="line">qiniu.bucket=xxx<span class="comment">//空间名</span></span><br></pre></td></tr></table></figure>
<p>UploadConfig.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(</span><br><span class="line">        prefix = <span class="string">"qiniu"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiniuUploadConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    <span class="keyword">private</span> String bucket;</span><br><span class="line">    <span class="keyword">private</span> String vhost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccessKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accessKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessKey</span><span class="params">(String accessKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accessKey = accessKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSecretKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecretKey</span><span class="params">(String secretKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secretKey = secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBucket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBucket</span><span class="params">(String bucket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bucket = bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVhost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vhost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVhost</span><span class="params">(String vhost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vhost = vhost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QiniuUploadController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/qiniu/upload"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiniuUploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    QiniuUploadConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"uptoken"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">uptoken</span><span class="params">(@RequestParam Map&lt;String, Object&gt; params)</span> <span class="keyword">throws</span> AuthException </span>&#123;</span><br><span class="line">        JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        Auth auth = Auth.create(config.getAccessKey(), config.getSecretKey()); </span><br><span class="line">        String upToken = auth.uploadToken(config.getBucket());</span><br><span class="line">        String domain = config.getVhost();</span><br><span class="line">        json.put(<span class="string">"uptoken"</span>, upToken);</span><br><span class="line">        json.put(<span class="string">"domain"</span>,domain);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成！😄。</p>
]]></content>
      <categories>
        <category>第三方</category>
      </categories>
      <tags>
        <tag>第三方</tag>
        <tag>JPush</tag>
      </tags>
  </entry>
  <entry>
    <title>解决“Docker have no space left on device”问题</title>
    <url>/2020/06/03/Docker-have-no-space-left-on-device/</url>
    <content><![CDATA[<h2 id="异常">异常</h2>
<p>像往常一样部署项目<code>./deploy.sh xx.jar</code>时,失败报<code>Docker have no space left on device</code>错误。于是我就用<code>docker system prune</code>删除无用的doker数据，但是还是依然报此错误。那就要想占据磁盘空间的主要因素一般是日志和docker所占的空间了，所以我们可以进行如下操作。</p>
<h2 id="解决办法">解决办法</h2>
<h3 id="删除日志">删除日志</h3>
<ol>
<li>df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。<br>
<code>df -h</code><br>
<img src="/images/df.png" alt=""></li>
<li>查看日志磁盘使用率<br>
<code>du /var/log/ -h</code><br>
<img src="/images/du-log.png" alt=""></li>
<li>进入日志目录，查看<br>
<code>cd /var/log</code><br>
<code>ls -alh</code><br>
这里面的日志一般都能删除，删除占磁盘空间大的，如删除文件前缀为btmp的<br>
<code>rm btmp-* -f</code></li>
<li>再次查看磁盘信息<br>
<code>df</code><br>
<img src="/images/df-1.png" alt=""></li>
</ol>
<h3 id="删除docker所占磁盘空间">删除docker所占磁盘空间</h3>
<ol>
<li>查看镜像<br>
<code>docker images</code><br>
<img src="/images/dockerimages.png" alt=""></li>
<li>批量删除无用镜像<br>
<code>docker images |cut -c41-53 |xargs docker rmi</code><br>
此条命令只能删除不重名且没有依赖的镜像</li>
<li>删除重名并且有依赖的废弃的镜像，例如删除5个月前的镜像<br>
<code>docker images |grep '5 months ago' |cut -c41-53 |xargs docker rmi -f</code></li>
<li>df再次查看磁盘所占空间<br>
<code>df</code><br>
<img src="/images/df-final.png" alt=""><br>
最后附送查看定时任务命令,😄<br>
<code>crontab -l</code></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2</title>
    <url>/2020/04/09/OAuth2/</url>
    <content><![CDATA[<h2 id="OAuth四种角色">OAuth四种角色</h2>
<p>完整授权流程中有四个重要的角色[ RFC 6749 ]：</p>
<p>资源拥有者（resource owner）：能授权访问受保护资源的一个实体，可以是一个人，那我们称之为最终用户；<br>
资源服务器（resource server）：存储受保护资源，客户端通过access token请求资源，资源服务器响应受保护资源给客户端；<br>
授权服务器（authorization server）：成功验证资源拥有者并获取授权之后，授权服务器颁发授权令牌（Access Token）给客户端。<br>
客户端（client）：第三方应用，也可以是它自己的官方应用；其本身不存储资源，而是资源拥有者授权通过后，使用它的授权（授权令牌）访问受保护资源，然后客户端把相应的数据展示出来/提交到服务器。</p>
<a id="more"></a>
<h2 id="客户端四种授权模式">客户端四种授权模式</h2>
<h3 id="Authorization-code（授权码模式）">Authorization code（授权码模式）</h3>
<p>标准的 Server 授权模式，非常适合 Server 端的 Web 应用。一旦资源的拥有者授权访问他们的数据之后，他们将会被重定向到 Web 应用并在 URL 的查询参数中附带一个授权码（code）。在客户端里，该 code 用于请求访问令牌（access_token）。并且该令牌交换的过程是两个服务端之前完成的，防止其他人甚至是资源拥有者本人得到该令牌。另外，在该授权模式下可以通过 refresh_token 来刷新令牌以延长访问授权时间，也是最为复杂的一种方式。</p>
<p>1、第三方应用向授权端点URI</p>
<p>GET <a href="https://b.com/oauth/authorize" target="_blank" rel="noopener">https://b.com/oauth/authorize</a>?<br>
response_type=code&amp;			// 表示授权码模式<br>
client_id=CLIENT_ID&amp;		        // 表示客户端id<br>
redirect_uri=CALLBACK_URL&amp;	        // 授权后跳转的url<br>
scope=read&amp;							// 要求的授权范围<br>
state=state							// 推荐的。一个不透明的值用于维护请求和回调之间的状态。授权服务器在将用户代理重定向会客户端的时候会带上该参数。<br>
2、返回授权码</p>
<p><a href="https://a.com/callback?code=AUTHORIZATION_CODE" target="_blank" rel="noopener">https://a.com/callback?code=AUTHORIZATION_CODE</a><br>
3、POST 请求令牌，向令牌端点发出请求</p>
<p>POST <a href="https://b.com/oauth/token" target="_blank" rel="noopener">https://b.com/oauth/token</a>?<br>
client_id=CLIENT_ID&amp;<br>
client_secret=CLIENT_SECRET&amp;<br>
grant_type=authorization_code&amp;<br>
code=AUTHORIZATION_CODE&amp;<br>
redirect_uri=CALLBACK_URL<br>
4、验证通过后返回令牌</p>
<p>{<br>
“access_token”:“ACCESS_TOKEN”,<br>
“token_type”:“bearer”,<br>
“expires_in”:2592000,<br>
“refresh_token”:“REFRESH_TOKEN”,<br>
“scope”:“read”,<br>
“uid”:100101,<br>
“info”:{…}<br>
}</p>
<h3 id="Implicit-Grant（隐式模式）">Implicit Grant（隐式模式）</h3>
<p>该模式是所有授权模式中最简单的一种，并为运行于浏览器中的脚本应用做了优化。当用户访问该应用时，服务端会立即生成一个新的访问令牌（access_token）并通过URL的#hash段传回客户端。这时，客户端就可以利用JavaScript等将其取出然后请求API接口。该模式不需要授权码（code），当然也不会提供refresh token以获得长期访问的入口。</p>
<p><a href="https://b.com/oauth/authorize" target="_blank" rel="noopener">https://b.com/oauth/authorize</a>?<br>
response_type=token&amp;<br>
client_id=CLIENT_ID&amp;<br>
redirect_uri=CALLBACK_URL&amp;<br>
scope=read<br>
用户认证后，直接返回令牌</p>
<p><a href="https://a.com/callback#token=ACCESS_TOKEN" target="_blank" rel="noopener">https://a.com/callback#token=ACCESS_TOKEN</a></p>
<h3 id="Resource-Owner-Password-Credentials（密码模式）">Resource Owner Password Credentials（密码模式）</h3>
<p>自己有一套用户体系，这种模式要求用户提供用户名和密码来交换访问令牌（access_token）。该模式仅用于非常值得信任的用户，例如API提供者本人所写的移动应用。虽然用户也要求提供密码，但并不需要存储在设备上。因为初始验证之后，只需将 OAuth 的令牌记录下来即可。如果用户希望取消授权，因为其真实密码并没有被记录，因此无需修改密码就可以立即取消授权。token本身也只是得到有限的授权，因此相比最传统的 username/password 授权，该模式依然更为安全。</p>
<p>1、客户端直接获取用户在资源服务器的账号密码，然后向认证服务器获取令牌</p>
<p><a href="https://oauth.b.com/token" target="_blank" rel="noopener">https://oauth.b.com/token</a>?<br>
grant_type=password&amp;<br>
username=USERNAME&amp;<br>
password=PASSWORD&amp;<br>
client_id=CLIENT_ID<br>
POST /token HTTP/1.1<br>
Host: <a href="http://server.example.com" target="_blank" rel="noopener">server.example.com</a><br>
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>
Content-Type: application/x-www-form-urlencoded</p>
<p>grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</p>
<h3 id="Client-Credentials（客户端模式）">Client Credentials（客户端模式）</h3>
<p>没有用户的概念，一种基于 APP 的密钥直接进行授权，因此 APP 的权限非常大。它适合像数据库或存储服务器这种对 API 的访问需求。</p>
<p><a href="https://oauth.b.com/token" target="_blank" rel="noopener">https://oauth.b.com/token</a>?<br>
grant_type=client_credentials&amp;<br>
client_id=CLIENT_ID&amp;<br>
client_secret=CLIENT_SECRET<br>
一搬 client_id 和 client_secret 加密作为请求头传输</p>
<p>POST /token HTTP/1.1<br>
Host: <a href="http://server.example.com" target="_blank" rel="noopener">server.example.com</a><br>
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>
Content-Type: application/x-www-form-urlencoded</p>
<p>grant_type=client_credentials</p>
<h2 id="Tips">Tips</h2>
<p>简单说下spring security oauth2的认证思路。</p>
<p>client模式，没有用户的概念，直接与认证服务器交互，用配置中的客户端信息去申请accessToken，客户端有自己的client_id,client_secret对应于用户的username,password，而客户端也拥有自己的authorities，当采取client模式认证时，对应的权限也就是客户端自己的authorities。<br>
password模式，自己本身有一套用户体系，在认证时需要带上自己的用户名和密码，以及客户端的client_id,client_secret。此时，accessToken所包含的权限是用户本身的权限，而不是客户端的权限。<br>
我对于两种模式的理解便是，如果你的系统已经有了一套用户体系，每个用户也有了一定的权限，可以采用password模式；如果仅仅是接口的对接，不考虑用户，则可以使用client模式。</p>
]]></content>
      <categories>
        <category>SpringCloud - OAuth2</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud Maven Module</title>
    <url>/2020/04/09/maven-module/</url>
    <content><![CDATA[<h2 id="项目模块说明">项目模块说明</h2>
<ul>
<li>microservice          --父项目，公共依赖
<ul>
<li>sysadmin          --子模块，后台admin项目</li>
<li>common            --子模块，公共模块</li>
<li>api               --子模块，移动Api</li>
<li>auth              --子模块，OAuth2鉴权
<ul>
<li>authorization-server              --授权模块</li>
<li>authorization-resource            --资源模块</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="pom-xml">pom.xml</h2>
<p>最外层父module</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;!-- &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;micro-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;relativePath /&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;microservice&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;microservice&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Cloud&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Hoxton.SR1&lt;/spring-cloud.version&gt;</span><br><span class="line">        &lt;swagger.version&gt;2.9.2&lt;/swagger.version&gt;</span><br><span class="line">        &lt;spring-boot-version&gt;2.2.2.RELEASE&lt;/spring-boot-version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--热加载--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--alibaba fastjson --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.62&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--lombok--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Swagger2 - RESTful API文档--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--nacos服务中心--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.9.0.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--测试--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;common&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;sysadmin&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;auth&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;api&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;authorization&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>common module pom.xml</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;microservice&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;!--&lt;relativePath&gt;../&lt;/relativePath&gt;--&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;common&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;common&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--web--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--redis--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--rabbitmq--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>auth作为子module,其下又有两个子module,auth module pom</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;!-- &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;micro-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;relativePath /&gt;</span><br><span class="line">    &lt;/parent&gt;--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;microservice&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">       &lt;!-- &lt;relativePath&gt;../&lt;/relativePath&gt;--&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;auth&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;auth&lt;/name&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--common公共服务中心--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.3.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--oauth2授权服务--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.security/spring-security-jwt --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.0.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeign --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>authorization-server module pom</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;auth&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">       &lt;!-- &lt;relativePath&gt;../&lt;/relativePath&gt;--&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;authorization-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.10.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- mysql --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--jpa--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>authorization-resource module pom</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;auth&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;!--&lt;relativePath&gt;../&lt;/relativePath&gt;--&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;authorization-resource&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- mysql --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>sysadmin module pom</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;microservice&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;!--&lt;relativePath&gt;../&lt;/relativePath&gt;--&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sysadmin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;sysadmin&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- mysql --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- security --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/cn.hutool/hutool-core --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hutool-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--jpa--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- test --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- Gson https:<span class="comment">//mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.8.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.assertj&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;assertj-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql cannot allocate memory for the buffer pool 解决方法</title>
    <url>/2020/03/30/mysql%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<h2 id="异常">异常</h2>
<p><img src="/images/mysql.png" alt=""></p>
<h2 id="原因">原因</h2>
<p>内存不足</p>
<a id="more"></a>
<h2 id="解决办法">解决办法</h2>
<p>mysql的配置都在/ect/mysql.cnf里面（Ubuntu目录有稍微的差别，用whereis my.cnf就能找到了）。<br>
<code>vim /etc/my.cnf</code><br>
<code>#innodb_buffer_pool_size = 128M</code><br>
这里显示默认配置是128M，是注释状态，我们只需要把注释去掉，把128改小一点（根据个人情况修改），我改为：<br>
<code>innodb_buffer_pool_size = 50M</code></p>
<h2 id="进一步优化">进一步优化</h2>
<p>一般出现这种问题的同学，内存肯定都不大，所以我们可以设置swap分区，也就是通常所说的虚拟内存。<br>
swap的作用具体这里就不做说明了，简单点说就是可以辅助Mem内存。<br>
直接上代码：</p>
<p><code>dd if=/dev/zero of=/swapfile bs=1M count=1024</code><br>
<code>mkswap /swapfile</code><br>
<code>swapon /swapfile</code></p>
<p>最后添加代码/swapfile swap swap defaults 0 0到/etc/fstab文件里面。<br>
然后命令<code>free</code>一下，能看到Mem和swap信息就说明成功了。<br>
最后重启mysql就可以了。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像下载</title>
    <url>/2020/03/26/docker%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="镜像下载速度慢？">镜像下载速度慢？</h2>
<p>具体解决办法就是使用阿里云镜像加速器，详情请参考<a href="https://blog.csdn.net/liu865033503/article/details/95936640" target="_blank" rel="noopener">Docker pull慢，无法pull问题解决(更改镜像源为阿里云国内镜像)</a>.<br>
但是按照配置好阿里云镜像后重启docker却报错，如下图：</p>
<a id="more"></a>
<p><img src="/images/docker.png" alt=""><br>
查阅资料后，原来是如果是配置了国内镜像，并且镜像文件为/etc/docker/daemon.json，则修改文件后缀为.conf即可正常启动docker 服务。</p>
<h2 id="开发常用镜像容器安装">开发常用镜像容器安装</h2>
<ul>
<li>Java<br>
<code>docker pull java</code></li>
<li>Mysql<br>
拉取镜像（指定5.7版本）<br>
<code>docker pull mysql:5.7</code><br>
启动容器<br>
<code>docker run --restart=always -p 3306:3306 --name mysql -v /data/apps/db:/var/lib/mysql  -d mysql:5.7</code></li>
<li>Redis<br>
拉取镜像<br>
<code>docker pull redis</code><br>
启动容器<br>
<code>docker run --restart=always -v /etc/redis.conf:/etc/redis.conf --name redis redis redis-server /etc/redis.conf</code></li>
<li>JenKins<br>
拉取镜像<br>
<code>docker pull jenkins</code><br>
查看镜像<br>
<code>docker images</code><br>
创建jenkins数据文件<br>
<code>mkdir /home/jenkins_home</code><br>
赋予权限<br>
<code>chmod 777 /home/jenkins_home </code><br>
启动容器<br>
<code>docker run -d --name jenkins -p 8002:8080 -p 50000:50000 -v /home/jenkins_home:/home/jenkins_home</code></li>
<li>Nacos<br>
拉取镜像（指定版本1.1.4）<br>
<code>docker pull nacos/nacos-server:1.1.4</code><br>
启动容器<br>
<code>docker run --env MODE=standalone --name nacos -d -p 8848:8848 nacos/nacos-server:1.1.4</code></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2020/03/20/vue/</url>
    <content><![CDATA[<h2 id="Vue项目目录初始化">Vue项目目录初始化</h2>
<p><a href="https://zhuanlan.zhihu.com/p/34898485" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>即时通讯IM</title>
    <url>/2020/03/19/tecent-im/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>最近在做一款直播app,涉及到了IM通讯，实现直播群组聊天，IM注册、登录，改换头像、昵称等。用的是腾讯IM。</p>
<h2 id="Api调用">Api调用</h2>
<h3 id="准备工作">准备工作</h3>
<p>服务端需记录腾讯IM控制台里的sdk app id及应用的密钥</p>
<a id="more"></a>
<h3 id="代码">代码</h3>
<p>Constant.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line">    <span class="comment">//IM通讯sdkappid    密钥</span></span><br><span class="line">    public static final Integer SDK_APPID = ######;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY = <span class="string">"#######################################3"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IDENTIFIER = <span class="string">"admin"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TimService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"timService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(TimService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"https://console.tim.qq.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SysLog</span>(<span class="string">"单账号导入"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProcessResult <span class="title">accountImport</span><span class="params">(String Identifier)</span> </span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"im_open_login_svc"</span>, <span class="string">"account_import"</span>, userSig);</span><br><span class="line">        Map jsonObj = Collections.singletonMap(<span class="string">"Identifier"</span>,Identifier);</span><br><span class="line">        HttpEntity&lt;String&gt; formEntity = <span class="keyword">new</span> HttpEntity&lt;String&gt;(JsonUtil.toJSON(jsonObj));</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, formEntity, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"OK"</span>.equalsIgnoreCase(result.get(<span class="string">"ActionStatus"</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProcessResult(ProcessResult.SUCCESS,<span class="string">"single account import success"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProcessResult(ProcessResult.ERROR,<span class="string">"single account import failure"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SysLog</span>(<span class="string">"创建群组"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createGroup</span><span class="params">(GoVideo goVideo)</span> </span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"group_open_http_svc"</span>, <span class="string">"create_group"</span>, userSig);</span><br><span class="line">        Map&lt;String, Object&gt; jsonObj = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//jsonObj.put("Owner_Account",username);群主的userId  待后期扩展</span></span><br><span class="line">        jsonObj.put(<span class="string">"Type"</span>,<span class="string">"AVChatRoom"</span>);<span class="comment">//音视频聊天室</span></span><br><span class="line">        jsonObj.put(<span class="string">"Name"</span>,<span class="string">"Group-"</span>+goVideo.getId());</span><br><span class="line">        jsonObj.put(<span class="string">"GroupId"</span>,<span class="string">"live-"</span>+goVideo.getId());</span><br><span class="line">        HttpEntity&lt;String&gt; formEntity = <span class="keyword">new</span> HttpEntity&lt;String&gt;(JsonUtil.toJSON(jsonObj));</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, formEntity, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SysLog</span>(<span class="string">"APP自定义脏字"</span>)</span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/addDirtyWOrd"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProcessResult <span class="title">addDirtyWord</span><span class="params">(@RequestBody String jsonString)</span> </span>&#123;</span><br><span class="line">        Map jsonObj = JsonUtil.fromJSON(jsonString, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"openim_dirty_words"</span>, <span class="string">"add"</span>, userSig);</span><br><span class="line">        HttpEntity&lt;String&gt; formEntity = <span class="keyword">new</span> HttpEntity&lt;String&gt;(JsonUtil.toJSON(jsonObj));</span><br><span class="line">        Map&lt;String, String&gt; rowData = restTemplate.postForObject(url, formEntity, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String actionStatus = rowData.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"OK"</span>.equalsIgnoreCase(actionStatus)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProcessResult(ProcessResult.SUCCESS,<span class="string">"add dirty word success"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProcessResult(ProcessResult.ERROR,<span class="string">"add dirty word failure :: "</span> + JsonUtil.toJSON(rowData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SysLog</span>(<span class="string">"解散群组"</span>)</span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/destroyGroup"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">destroyGroup</span><span class="params">(GoVideo goVideo)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; jsonObj = <span class="keyword">new</span> HashMap();</span><br><span class="line">        jsonObj.put(<span class="string">"GroupId"</span>,goVideo.getGroupId());</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"group_open_http_svc"</span>, <span class="string">"destroy_group"</span>, userSig);</span><br><span class="line">        HttpEntity&lt;String&gt; formEntity = <span class="keyword">new</span> HttpEntity&lt;String&gt;(JsonUtil.toJSON(jsonObj));</span><br><span class="line">        Map&lt;String, String&gt; rowData = restTemplate.postForObject(url, formEntity, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        log.info(<span class="string">"===========解散群组================== &#123;&#125;"</span>, goVideo.getGroupId());</span><br><span class="line">        <span class="keyword">return</span> rowData.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * im注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nickName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> faceUrl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">registe</span><span class="params">(String uuid,String nickName,String faceUrl)</span></span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"im_open_login_svc"</span>,<span class="string">"account_import"</span>,userSig);</span><br><span class="line">        Map&lt;String,Object&gt; jsonObj = <span class="keyword">new</span> HashMap();</span><br><span class="line">        jsonObj.put(<span class="string">"Identifier"</span>,uuid);</span><br><span class="line">        jsonObj.put(<span class="string">"Nick"</span>,nickName);</span><br><span class="line">        jsonObj.put(<span class="string">"FaceUrl"</span>,faceUrl);</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, jsonObj, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * im修改头像</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateImFaceUrl</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"profile"</span>, <span class="string">"portrait_set"</span>, userSig);</span><br><span class="line">        ArrayList&lt;Object&gt; profileItem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Object&gt; jsonObj = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        jsonObj.put(<span class="string">"Tag"</span>, <span class="string">"Tag_Profile_IM_Image"</span>);</span><br><span class="line">        jsonObj.put(<span class="string">"Value"</span>, user.getAvatar());</span><br><span class="line">        profileItem.add(jsonObj);</span><br><span class="line">        MapBuild&lt;String, String&gt; obj = <span class="keyword">new</span> MapBuild&lt;String, String&gt;().put(<span class="string">"From_Account"</span>,user.getUuid()).put(<span class="string">"ProfileItem"</span>, profileItem);</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, obj.build(), Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * im修改昵称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uuid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nickName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateImNick</span><span class="params">(String uuid,String nickName)</span> </span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"profile"</span>, <span class="string">"portrait_set"</span>, userSig);</span><br><span class="line">        ArrayList&lt;Object&gt; profileItem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Object&gt; jsonObj = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        jsonObj.put(<span class="string">"Tag"</span>, <span class="string">"Tag_Profile_IM_Nick"</span>);</span><br><span class="line">        jsonObj.put(<span class="string">"Value"</span>, nickName);</span><br><span class="line">        profileItem.add(jsonObj);</span><br><span class="line">        MapBuild&lt;String, String&gt; obj = <span class="keyword">new</span> MapBuild&lt;String, String&gt;().put(<span class="string">"From_Account"</span>, uuid).put(<span class="string">"ProfileItem"</span>, profileItem);</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, obj.build(), Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uuid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProfilePortrait</span><span class="params">(String uuid)</span></span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"profile"</span>,<span class="string">"portrait_get"</span>,userSig);</span><br><span class="line">        MapBuild&lt;String, String[]&gt; obj = <span class="keyword">new</span> MapBuild&lt;String, String[]&gt;().put(<span class="string">"To_Account"</span>,<span class="keyword">new</span> String[] &#123;uuid&#125;)</span><br><span class="line">                .put(<span class="string">"TagList"</span>,<span class="keyword">new</span> String[] &#123;<span class="string">"Tag_Profile_IM_Nick"</span>,<span class="string">"Tag_Profile_IM_Image"</span>&#125;);</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, obj.build(), Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">formatUrl</span><span class="params">(String serviceName, String cmdName, String usersig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> rd = Math.random() * <span class="number">999_999_999</span>;</span><br><span class="line">        String url = String.format(<span class="string">"%s/v4/%s/%s?usersig=%s&amp;identifier=%s&amp;sdkappid=%s&amp;random=%d&amp;contenttype=json"</span>, HOST, serviceName, cmdName, usersig, Constant.IDENTIFIER, Constant.SDK_APPID,</span><br><span class="line">                (<span class="keyword">int</span>) rd);</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SysLog</span>(<span class="string">"获取userSig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserSig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TLSSigAPIv2 api = <span class="keyword">new</span> TLSSigAPIv2(Constant.SDK_APPID, Constant.KEY);</span><br><span class="line">        String userSig = api.genSig(Constant.IDENTIFIER , <span class="number">180</span> * <span class="number">86400</span>);</span><br><span class="line">        <span class="keyword">return</span> userSig;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>工具类TLSSigAPIv2.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xy.goone.modules.sys.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.net.util.Base64;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Mac;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.InvalidKeyException;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.Deflater;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TLSSigAPIv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sdkappid;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TLSSigAPIv2</span><span class="params">(<span class="keyword">long</span> sdkappid, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sdkappid = sdkappid;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">hmacsha256</span><span class="params">(String identifier, <span class="keyword">long</span> currTime, <span class="keyword">long</span> expire, String base64Userbuf)</span> </span>&#123;</span><br><span class="line">        String contentToBeSigned = <span class="string">"TLS.identifier:"</span> + identifier + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"TLS.sdkappid:"</span> + sdkappid + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"TLS.time:"</span> + currTime + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"TLS.expire:"</span> + expire + <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != base64Userbuf) &#123;</span><br><span class="line">            contentToBeSigned += <span class="string">"TLS.userbuf:"</span> + base64Userbuf + <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] byteKey = key.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">            Mac hmac = Mac.getInstance(<span class="string">"HmacSHA256"</span>);</span><br><span class="line">            SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(byteKey, <span class="string">"HmacSHA256"</span>);</span><br><span class="line">            hmac.init(keySpec);</span><br><span class="line">            <span class="keyword">byte</span>[] byteSig = hmac.doFinal(contentToBeSigned.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            <span class="comment">//return new String(Base64.encodeBase64(byteSig)).replaceAll("\\s*", "");</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> BASE64Encoder().encode(byteSig)).replaceAll(<span class="string">"\\s*"</span>, <span class="string">""</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidKeyException  e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">genSig</span><span class="params">(String identifier, <span class="keyword">long</span> expire, <span class="keyword">byte</span>[] userbuf)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currTime = System.currentTimeMillis()/<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        JSONObject sigDoc = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        sigDoc.put(<span class="string">"TLS.ver"</span>, <span class="string">"2.0"</span>);</span><br><span class="line">        sigDoc.put(<span class="string">"TLS.identifier"</span>, identifier);</span><br><span class="line">        sigDoc.put(<span class="string">"TLS.sdkappid"</span>, sdkappid);</span><br><span class="line">        sigDoc.put(<span class="string">"TLS.expire"</span>, expire);</span><br><span class="line">        sigDoc.put(<span class="string">"TLS.time"</span>, currTime);</span><br><span class="line"></span><br><span class="line">        String base64UserBuf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != userbuf) &#123;</span><br><span class="line">            <span class="comment">//base64UserBuf = new String(Base64.encodeBase64(userbuf));</span></span><br><span class="line">            base64UserBuf = <span class="keyword">new</span> BASE64Encoder().encode(userbuf);</span><br><span class="line">            sigDoc.put(<span class="string">"TLS.userbuf"</span>, base64UserBuf);</span><br><span class="line">        &#125;</span><br><span class="line">        String sig = hmacsha256(identifier, currTime, expire, base64UserBuf);</span><br><span class="line">        <span class="keyword">if</span> (sig.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sigDoc.put(<span class="string">"TLS.sig"</span>, sig);</span><br><span class="line">        Deflater compressor = <span class="keyword">new</span> Deflater();</span><br><span class="line">        compressor.setInput(sigDoc.toString().getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">        compressor.finish();</span><br><span class="line">        <span class="keyword">byte</span> [] compressedBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> compressedBytesLength = compressor.deflate(compressedBytes);</span><br><span class="line">        compressor.end();</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> String(Base64URL.base64EncodeUrl(Arrays.copyOfRange(compressedBytes,</span><br><span class="line">                <span class="number">0</span>, compressedBytesLength)))).replaceAll(<span class="string">"\\s*"</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">genSig</span><span class="params">(String identifier, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> genSig(identifier, expire, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">genSigWithUserBuf</span><span class="params">(String identifier, <span class="keyword">long</span> expire, <span class="keyword">byte</span>[] userbuf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> genSig(identifier, expire, userbuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xy.goone.tengxim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xy.goone.common.Constant;</span><br><span class="line"><span class="keyword">import</span> com.xy.goone.common.util.MapBuild;</span><br><span class="line"><span class="keyword">import</span> com.xy.goone.modules.domain.User;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fumei.jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImMessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"https://console.tim.qq.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * im注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nickName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> faceUrl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">registe</span><span class="params">(String uuid,String nickName,String faceUrl)</span></span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"im_open_login_svc"</span>,<span class="string">"account_import"</span>,userSig);</span><br><span class="line">        Map&lt;String,Object&gt; jsonObj = <span class="keyword">new</span> HashMap();</span><br><span class="line">        jsonObj.put(<span class="string">"Identifier"</span>,uuid);</span><br><span class="line">        jsonObj.put(<span class="string">"Nick"</span>,nickName);</span><br><span class="line">        jsonObj.put(<span class="string">"FaceUrl"</span>,faceUrl);</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, jsonObj, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * im修改头像</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateImFaceUrl</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"profile"</span>, <span class="string">"portrait_set"</span>, userSig);</span><br><span class="line">        ArrayList&lt;Object&gt; profileItem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Object&gt; jsonObj = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        jsonObj.put(<span class="string">"Tag"</span>, <span class="string">"Tag_Profile_IM_Image"</span>);</span><br><span class="line">        jsonObj.put(<span class="string">"Value"</span>, user.getAvatar());</span><br><span class="line">        profileItem.add(jsonObj);</span><br><span class="line">        MapBuild&lt;String, String&gt; obj = <span class="keyword">new</span> MapBuild&lt;String, String&gt;().put(<span class="string">"From_Account"</span>,user.getUuid()).put(<span class="string">"ProfileItem"</span>, profileItem);</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, obj.build(), Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateImNick</span><span class="params">(String uuid,String nickName)</span> </span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"profile"</span>, <span class="string">"portrait_set"</span>, userSig);</span><br><span class="line">        ArrayList&lt;Object&gt; profileItem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Object&gt; jsonObj = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        jsonObj.put(<span class="string">"Tag"</span>, <span class="string">"Tag_Profile_IM_Nick"</span>);</span><br><span class="line">        jsonObj.put(<span class="string">"Value"</span>, nickName);</span><br><span class="line">        profileItem.add(jsonObj);</span><br><span class="line">        MapBuild&lt;String, String&gt; obj = <span class="keyword">new</span> MapBuild&lt;String, String&gt;().put(<span class="string">"From_Account"</span>, uuid).put(<span class="string">"ProfileItem"</span>, profileItem);</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, obj.build(), Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProfilePortrait</span><span class="params">(String uuid)</span></span>&#123;</span><br><span class="line">        String userSig = getUserSig();</span><br><span class="line">        String url = formatUrl(<span class="string">"profile"</span>,<span class="string">"portrait_get"</span>,userSig);</span><br><span class="line">        MapBuild&lt;String, String[]&gt; obj = <span class="keyword">new</span> MapBuild&lt;String, String[]&gt;().put(<span class="string">"To_Account"</span>,<span class="keyword">new</span> String[] &#123;uuid&#125;)</span><br><span class="line">                .put(<span class="string">"TagList"</span>,<span class="keyword">new</span> String[] &#123;<span class="string">"Tag_Profile_IM_Nick"</span>,<span class="string">"Tag_Profile_IM_Image"</span>&#125;);</span><br><span class="line">        Map&lt;String, String&gt; result = restTemplate.postForObject(url, obj.build(), Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="string">"ActionStatus"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserSig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TLSSigAPIv2 api = <span class="keyword">new</span> TLSSigAPIv2(Constant.SDK_APPID, Constant.KEY);</span><br><span class="line">        String userSig = api.genSig(Constant.IDENTIFIER, <span class="number">180</span> * <span class="number">86400</span>);</span><br><span class="line">        <span class="keyword">return</span> userSig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">formatUrl</span><span class="params">(String serviceName, String cmdName, String usersig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> rd = Math.random() * <span class="number">999_999_999</span>;</span><br><span class="line">        String url = String.format(<span class="string">"%s/v4/%s/%s?usersig=%s&amp;identifier=%s&amp;sdkappid=%s&amp;random=%d&amp;contenttype=json"</span>, HOST, serviceName, cmdName, usersig, Constant.IDENTIFIER, Constant.SDK_APPID,</span><br><span class="line">                (<span class="keyword">int</span>) rd);</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MapBuild.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapBuild</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MapBuild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MapBuild</span><span class="params">(Map&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.map = map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.containsKey(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.containsValue(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.get(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MapBuild&lt;K, V&gt; <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">		map.put(key, value);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> MapBuild&lt;K, V&gt; <span class="title">put</span><span class="params">(K key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">		map.put(key, (V) value);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> MapBuild&lt;K, V&gt; <span class="title">put</span><span class="params">(K key, Integer integer)</span> </span>&#123;</span><br><span class="line">		map.put(key, (V) integer);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MapBuild&lt;K, V&gt; <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">		map.putAll(m);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MapBuild&lt;K, V&gt; <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		map.clear();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.keySet();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.values();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">		<span class="keyword">return</span> map.entrySet();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.equals(o);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.hashCode();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;K, V&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第三方</category>
      </categories>
      <tags>
        <tag>第三方</tag>
        <tag>腾讯IM</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud gateway异常</title>
    <url>/2020/01/08/springcloud-gateway%E5%90%AF%E5%8A%A8%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="异常">异常</h2>
<p>异常1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type <span class="string">'org.springframework.core.convert.ConversionService'</span> available: expected at least <span class="number">1</span> bean which qualifies as autowire candidate. Dependency annotations: &#123;<span class="meta">@org</span>.springframework.beans.factory.annotation.Qualifier(value=webFluxConversionService)&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>异常2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.context.ApplicationContextException: Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 解决过程</span><br><span class="line">在搞SpringCloud GateWay时，死活启动不起来，google了一下。</span><br><span class="line">原因1：&#96;spring cloud gateway&#96; 是&#96;webflux&#96; 项目，引了含有&#96;web-starter&#96;得项目就会出现冲突。因为&#96;Hystrix-dashboard&#96;中含有&#96;web-starter&#96;，所以出现冲突。</span><br><span class="line">解决方式：去掉 pom.xml 中的 &#96;spring-boot-starter-web &#96;部分。</span><br><span class="line">结果：排除web依赖之后依旧不好使。</span><br><span class="line">原因2：webflux与mvc不兼容，如类路径中引用了webmvc会导致项目启动不起来</span><br><span class="line">解决方式：找到依赖webmvc的jar包，将webmvc排除即可</span><br><span class="line">eg:</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;$&#123;project.groupId&#125;&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;core&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;exclusions&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            1. webflux与webmvc不兼容，否则会项目启动不起来</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>后来又看说是springboot版本不兼容问题，不管了，死马当活马医吧，将我的2.2.2改为2.0.5，成功了！！！<br>
<a href="https://www.okcode.net/article/39299" target="_blank" rel="noopener">参考文章</a><br>
最后修改springboot版本就好了，我的由2.2.2改为2.0.5，好像是2.1以上的版本不兼容。</p>
<p>关于webflux与mvc不兼容项目启动不起来的异常，如果项目中存在了tomcat的用来，则抛出的异常是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.context.ApplicationContextException: Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean.</span><br></pre></td></tr></table></figure>
<p>而如果没有依赖tomcat则抛出的异常是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type <span class="string">'org.springframework.core.convert.ConversionService'</span> available: expected at least <span class="number">1</span> bean which qualifies as autowire candidate. Dependency annotations: &#123;<span class="meta">@org</span>.springframework.beans.factory.annotation.Qualifier(value=webFluxConversionService)&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java异常</category>
      </categories>
      <tags>
        <tag>Java异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2019/12/30/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="开篇">开篇</h2>
<p>Docker越来越受大家欢迎，越来越被越多的人使用。借助Docker，您可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。那么，其实在linux服务器上使用docker来部署java项目，其实是非常简单的。至于它的安装网上也都有，这里我就不卖瓜了😀。我想跟大家说的是平时我使用docker的几条命令。记住这几条常用命令基本就可以简单地运用docker发布运行java jar包了。</p>
<a id="more"></a>
<h2 id="准备">准备</h2>
<p>首先，我前边写到Dockerfile及.deploy.sh自动部署配置文件，附上我的两文链接<a href="https://jiangfumei.github.io/2019/11/14/docker-dockerfile/">DockerFile配置</a>和<a href="https://jiangfumei.github.io/2019/11/14/docker-deploysh/">.deploy.sh部署脚本</a>。然后上传你的jar包</p>
<h2 id="命令">命令</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./deploy.sh xxx.jar conf/ yyy</span><br></pre></td></tr></table></figure>
<p>xxx.jar就是你的jar包名字，conf/就是你的项目的线上配置文件，yyy就是你要部署的java容器的名字。其实这条命令就会自动重启部署，包含</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t yyy</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name yyy -p 8080:8080 -d yyy</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs yyy --tail 1000 -f</span><br></pre></td></tr></table></figure>
<p>–tail 1000是查看最新1000行的yyy的日志，如果你想查看带有例如“启动完成”的log信息的日志可以这样写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs yyy | grep '启动完成'</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>列举出运行中的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>列举所有的容器，包括运行失败的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it yyy</span><br></pre></td></tr></table></figure>
<p>进入名字为yyy的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -rf yyy</span><br></pre></td></tr></table></figure>
<p>移除名为yyy的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect yyy</span><br></pre></td></tr></table></figure>
<p>检查名为yyy的配置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>查看镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi xxx</span><br></pre></td></tr></table></figure>
<p>删除名为xxx的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start yyy</span><br></pre></td></tr></table></figure>
<p>启动yyy容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop yyy</span><br></pre></td></tr></table></figure>
<p>停止yyy容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart yyy</span><br></pre></td></tr></table></figure>
<p>重启yyy容器<br>
基本上我常用的命令就是这些，接下来再给大家说一下创建比如redis、mysql等开发环境的容器的推荐命令</p>
<h2 id="创建开发系统环境命令">创建开发系统环境命令</h2>
<p>创建redis容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  --restart=always -p 6379:6379 --name redis  -d redis:3.2 redis-server --appendonly yes</span><br></pre></td></tr></table></figure>
<p><code>--restart=always</code>指一旦容器挂了立马重启，<code>-p 6379:6379</code>指将容器内部使用的网络端口映射到我们使用的主机上（开房容器端口和默认服务端口）。<code>redis-server --appendonly yes</code>开启永久化存储</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  --restart=always -p 6379:6379 --name redis -v /data/apps/redis:/var/redis  -d redis:3.2 redis-server --appendonly yes</span><br></pre></td></tr></table></figure>
<p>-v指的是挂载目录，映射宿主机的目录到容器，以便备份容器（宿主机存储在/data/apps/redis目录下，容器存储在/var/redis目录下）<br>
如果是想用我们的配置文件，则使用下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -v /etc/redis.conf:/etc/redis.conf --name redis redis redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure>
<p>创建mysql容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -p 3306:3306 --name mysql -v /data/apps/db:/var/lib/mysql  -d mysql:5.7</span><br></pre></td></tr></table></figure>
<p>大功告成！😆😆😆</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库迁移</title>
    <url>/2019/12/27/redis%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>一次死活连不上某redis数据库，但是我又想把里面的数据弄出来，so,下面就只说一下我是怎么把redis数据从192.168.10.ss迁移到192.168.1.xxx上.<br>
首先我要附上我的参考文章链接<a href="https://www.cnblogs.com/lina520/p/9606378.html" target="_blank" rel="noopener">redis数据迁移</a><br>
其次，附上我的命令：</p>
<a id="more"></a>
<p>1.登录192.168.1.xxx服务器，<code>docker ps</code>查看redis容器<br>
2.<code>docker exec -it redis bin/bash</code>(redis为redis容器的名字或id)<br>
3.<code>redis-cli -h 192.168.10.ss -n 0 -a 密码 keys '*' | xargs -i redis-cli -h 192.168.10.ss -n 0 -a 密码  migrate 192.168.1.xxx 6379 {} 5 10000</code><br>
“|”之前表示的是列出192.168.10.ss服务器上redis数据库为0的所有key,-a 密码附上权限用户密码，“|” 之后意思是把192.168.10.ss上的redis数据库为0的数据迁移到192.168.1.xxx上的数据库为5的redis数据库。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot接入苹果内购</title>
    <url>/2019/12/24/iospay/</url>
    <content><![CDATA[<h1>苹果内购</h1>
<p>在上一篇给大家描述了google支付的集成后，苹果内购也是必不可少的。就我而言，感觉苹果内购比google支付要简单容易得多，因为苹果内购撸代码前不需要配置准备，只需要在代码里集成就行了。废话少说，接下来还是分享一下我是如何集成苹果内购的。<br>
首先需要一个苹果支付工具类，这里是<code>IosVerifyUtil.java</code>:</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xy.goone.common.util.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.*;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fumei.jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-15 18:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 苹果内购工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IosVerifyUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustAnyTrustManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> X509Certificate[] &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustAnyHostnameVerifier</span> <span class="keyword">implements</span> <span class="title">HostnameVerifier</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url_sandbox = <span class="string">"https://sandbox.itunes.apple.com/verifyReceipt"</span>;<span class="comment">//沙盒测试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url_verify = <span class="string">"https://buy.itunes.apple.com/verifyReceipt"</span>;<span class="comment">//正式测试</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IOS_SHARED_SECRET_PASSWORD = <span class="string">"#######################"</span>;<span class="comment">//苹果连续订阅共享密钥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 苹果服务器验证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receipt</span></span><br><span class="line"><span class="comment">     * 账单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@url</span> 要验证的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null 或返回结果 沙盒 https://sandbox.itunes.apple.com/verifyReceipt</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buyAppVerify</span><span class="params">(String receipt,<span class="keyword">int</span> type,<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line"><span class="comment">//环境判断 线上/开发环境用不同的请求链接</span></span><br><span class="line">        String url = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">0</span>)&#123;</span><br><span class="line">            url = url_sandbox; <span class="comment">//沙盒测试</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            url = url_verify; <span class="comment">//线上测试</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SSLContext sc = SSLContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line">            sc.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[] &#123; <span class="keyword">new</span> TrustAnyTrustManager() &#125;, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line">            URL console = <span class="keyword">new</span> URL(url);</span><br><span class="line">            HttpsURLConnection conn = (HttpsURLConnection) console.openConnection();</span><br><span class="line">            conn.setSSLSocketFactory(sc.getSocketFactory());</span><br><span class="line">            conn.setHostnameVerifier(<span class="keyword">new</span> TrustAnyHostnameVerifier());</span><br><span class="line">            conn.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">"content-type"</span>, <span class="string">"text/json"</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">"Proxy-Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">            conn.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">            conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            BufferedOutputStream hurlBufOus = <span class="keyword">new</span> BufferedOutputStream(conn.getOutputStream());</span><br><span class="line">            String str = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">/* if (status==0)&#123;//消耗</span></span><br><span class="line"><span class="comment">                // 拼成固定的格式传给平台</span></span><br><span class="line"><span class="comment">                str = String.format(Locale.CHINA, "&#123;\"receipt-data\":\"" + receipt + "\"&#125;");//消耗型内购</span></span><br><span class="line"><span class="comment">            &#125;else if (status == 1)&#123;*/</span></span><br><span class="line">                <span class="comment">//连续包月订阅需要加上共享密钥</span></span><br><span class="line">                str = String.format(Locale.CHINA, <span class="string">"&#123;\"receipt-data\":\""</span> + receipt + <span class="string">"\",\"password\":\""</span> + IOS_SHARED_SECRET_PASSWORD + <span class="string">"\"&#125;"</span>);</span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            hurlBufOus.write(str.getBytes());</span><br><span class="line">            hurlBufOus.flush();</span><br><span class="line"></span><br><span class="line">            InputStream is = conn.getInputStream();</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"苹果服务器异常"</span>);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用BASE64加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getBASE64</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = str.getBytes();</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = <span class="keyword">new</span> sun.misc.BASE64Encoder().encode(b);</span><br><span class="line">            <span class="comment">//s = new String(Base64.encodeBase64(b));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OrderController.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/iosPaymentVerify"</span>)</span><br><span class="line">    <span class="meta">@Authorization</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"苹果内购支付"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;Object&gt; <span class="title">iosPayment</span><span class="params">(@RequestBody Map&lt;String, String&gt; map, @CurrentUser User user)</span> </span>&#123;</span><br><span class="line">        String no = map.get(<span class="string">"no"</span>);</span><br><span class="line">        String transactionId = map.get(<span class="string">"transactionId"</span>);</span><br><span class="line">        String types = map.get(<span class="string">"type"</span>);</span><br><span class="line">        <span class="keyword">int</span> type = Integer.valueOf(types.trim()); <span class="comment">//0消耗型 1订阅型</span></span><br><span class="line">        String payload = map.get(<span class="string">"payload"</span>);</span><br><span class="line">        log.info(<span class="string">"交易号:&#123;&#125;,receipt:&#123;&#125;,交易类型:&#123;&#125;,本地订单号:&#123;&#125;"</span>, transactionId, payload, type, no);</span><br><span class="line">        IosPayment iosPayment = iosPaymentService.save(no, transactionId, type, payload, user);</span><br><span class="line">        <span class="comment">//先校对与本地订单</span></span><br><span class="line">        Order localOrder = orderRepository.findByNo(no);<span class="comment">//禁止重复刷单</span></span><br><span class="line">        <span class="keyword">if</span> (localOrder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setErrorMsg(<span class="keyword">this</span>.i18n(<span class="string">"this.order.does.not.exist.and.the.recharge.failed"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (localOrder.getStatus() == Constant.PAY_SUCCESS || (localOrder.getTransactionId() != <span class="keyword">null</span> &amp;&amp; localOrder.getStatus() == Constant.PAY_SUCCESS)) &#123;<span class="comment">//本地订单号和苹果交易号每次购买都是唯一的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setErrorMsg(<span class="keyword">this</span>.i18n(<span class="string">"this.order.has.been.successfully.recharged.and.cannot.be.refilled"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String verifyResult = <span class="keyword">null</span>;</span><br><span class="line">        String receipt = payload.replaceAll(<span class="string">"%2B"</span>, <span class="string">"+"</span>); <span class="comment">//notice: 注意%2B的符号</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            verifyResult = IosVerifyUtil.buyAppVerify(receipt, <span class="number">1</span>, type);<span class="comment">//1.先线上测试,发送平台验证</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> HttpRequestException.newI18N(<span class="string">"server.exception"</span>);<span class="comment">//服务器异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (verifyResult == <span class="keyword">null</span>) &#123;<span class="comment">// 苹果服务器没有返回验证结果</span></span><br><span class="line">            <span class="keyword">throw</span> HttpRequestException.newI18N(<span class="string">"order.information.is.abnormal"</span>);<span class="comment">//订单信息异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 苹果验证有返回结果</span></span><br><span class="line">            log.info(<span class="string">"线上，苹果平台返回JSON:&#123;&#125;"</span>, verifyResult);</span><br><span class="line">            JSONObject job = JSONObject.parseObject(verifyResult);</span><br><span class="line">            String states = job.getString(<span class="string">"status"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"21007"</span>.equals(states)) &#123;<span class="comment">//是沙盒环境，应沙盒测试，否则执行下面</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    verifyResult = IosVerifyUtil.buyAppVerify(receipt, <span class="number">0</span>, type);<span class="comment">//2.再沙盒测试  发送平台验证</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> HttpRequestException.newI18N(<span class="string">"server.exception"</span>);<span class="comment">//服务器异常</span></span><br><span class="line">                &#125;</span><br><span class="line">                job = JSONObject.parseObject(verifyResult);</span><br><span class="line">                states = job.getString(<span class="string">"status"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (states.equals(<span class="string">"0"</span>)) &#123;<span class="comment">// 前端所提供的收据是有效的，验证成功</span></span><br><span class="line">                String r_receipt = job.getString(<span class="string">"receipt"</span>);</span><br><span class="line">                JSONObject returnJson = JSONObject.parseObject(r_receipt);</span><br><span class="line">                String in_app = returnJson.getString(<span class="string">"in_app"</span>);</span><br><span class="line">                JSONArray arr = JSONArray.parseArray(in_app);<span class="comment">//数组</span></span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//如果单号一致  则保存到数据库</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">                        JSONObject obj = (JSONObject) arr.get(i);</span><br><span class="line">                        <span class="comment">// 交易中有当前交易，则认为交易成功</span></span><br><span class="line">                        <span class="keyword">if</span> (transactionId.equals(obj.get(<span class="string">"transaction_id"</span>))) &#123;</span><br><span class="line">                            flag = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123;<span class="comment">//处理业务逻辑</span></span><br><span class="line">                            String productId = obj.getString(<span class="string">"product_id"</span>);</span><br><span class="line">                            Product product = productService.getByProductId(productId).orElseThrow(() -&gt; &#123;</span><br><span class="line">                                <span class="keyword">return</span> HttpRequestException.newI18N(<span class="string">"not.find.product"</span>);</span><br><span class="line">                            &#125;);</span><br><span class="line">                            String original_transaction_id = obj.getString(<span class="string">"original_transaction_id"</span>);</span><br><span class="line">                            <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;<span class="comment">//消耗型</span></span><br><span class="line">                                <span class="keyword">long</span> purchase_date = obj.getLong(<span class="string">"purchase_date_ms"</span>);</span><br><span class="line">                                <span class="keyword">int</span> amount = product.getAmount();<span class="comment">//充值的coin</span></span><br><span class="line">                                <span class="keyword">int</span> sum = user.getCoin() + amount;</span><br><span class="line">                                user.setCoin(sum);</span><br><span class="line">                                localOrder.setType(type);<span class="comment">//消耗型</span></span><br><span class="line">                                localOrder.setTransactionId(transactionId);</span><br><span class="line">                                localOrder.setStatus(Constant.PAY_SUCCESS);</span><br><span class="line">                                localOrder.setProduct(product);</span><br><span class="line">                                localOrder.setQuantity(amount);</span><br><span class="line">                                localOrder.setOriginTraId(original_transaction_id);</span><br><span class="line">                                orderService.updateOrder(localOrder);</span><br><span class="line">                                userService.updateUser(user);<span class="comment">//给用户加币</span></span><br><span class="line">                                billRecordService.save(amount, <span class="number">1</span>, <span class="string">"ポイント購入"</span>, user);</span><br><span class="line">                                iosPayment.setPurchaseDate(<span class="keyword">new</span> Date(purchase_date));</span><br><span class="line">                                iosPayment.setLatestReceipt(obj.toString());</span><br><span class="line">                                iosPaymentService.update(iosPayment, payload, original_transaction_id, product, IosPayment.Status.Completed);<span class="comment">//苹果支付详情</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setData(user.getCoin());</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;<span class="comment">//订阅型</span></span><br><span class="line">                                <span class="keyword">return</span> iosSubscribe(user, payload, transactionId, type, localOrder, job, obj, productId, product, iosPayment);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception is &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">                    <span class="keyword">throw</span> HttpRequestException.newI18N(<span class="string">"recharge.failed"</span>);<span class="comment">//充值失败</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> HttpRequestException.newI18N(<span class="string">"invalid.receipt.information"</span>);<span class="comment">//收据信息异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setErrorMsg(<span class="keyword">this</span>.i18n(<span class="string">"there.is.a.problem.with.the.order.verification"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Result&lt;Object&gt; <span class="title">iosSubscribe</span><span class="params">(@CurrentUser User user, String payload, String transactionId, <span class="keyword">int</span> type, Order localOrder, JSONObject job, JSONObject obj, String productId, Product product, IosPayment iosPayment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首次订阅与连续性订阅的区别判断</span></span><br><span class="line">        String originTransactionId = obj.getString(<span class="string">"original_transaction_id"</span>);<span class="comment">//现交易中的原始订单号，作为续费判定的依据</span></span><br><span class="line">        <span class="keyword">long</span> purchase_date = obj.getLong(<span class="string">"purchase_date_ms"</span>);</span><br><span class="line">        <span class="keyword">long</span> expires_date = obj.getLong(<span class="string">"expires_date_ms"</span>);</span><br><span class="line">        Date expiresTime = <span class="keyword">new</span> Date(expires_date);</span><br><span class="line">        Date joinTime = <span class="keyword">new</span> Date(purchase_date);</span><br><span class="line">        log.info(<span class="string">"expiresTime is &#123;&#125;"</span>, expiresTime);</span><br><span class="line">        log.info(<span class="string">"joinTime is &#123;&#125;"</span>, joinTime);</span><br><span class="line">        <span class="keyword">boolean</span> is_trial_period = <span class="keyword">true</span>;<span class="comment">//是否处于试用期间</span></span><br><span class="line">        String isTrial = obj.getString(<span class="string">"is_trial_period"</span>);</span><br><span class="line">        is_trial_period = Boolean.parseBoolean(isTrial);</span><br><span class="line">        <span class="keyword">if</span> (is_trial_period) &#123;<span class="comment">//免费试用期间</span></span><br><span class="line">            user.setType(<span class="number">1</span>);</span><br><span class="line">            user.setJoinTime(joinTime);<span class="comment">//会员加入时间</span></span><br><span class="line">            user.setExpireTime(expiresTime);<span class="comment">//会员过期时间</span></span><br><span class="line">            iosPayment.setExpiresDate(expiresTime);</span><br><span class="line">            iosPayment.setPurchaseDate(<span class="keyword">new</span> Date(purchase_date));</span><br><span class="line">            log.info(<span class="string">"user id &#123;&#125; 首次订阅成功，体验一个月免费试用期"</span>, user.getId());</span><br><span class="line">            <span class="keyword">return</span> sucribeSuccess(user, payload, transactionId, originTransactionId, type, localOrder, product, iosPayment);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//用户取消后又重新订阅判断依据</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(job.getString(<span class="string">"pending_renewal_info"</span>))) &#123;</span><br><span class="line">            JSONArray renewals = JSONArray.parseArray(job.getString(<span class="string">"pending_renewal_info"</span>));</span><br><span class="line">            JSONArray pendings = <span class="keyword">new</span> JSONArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; renewals.size(); p++) &#123;</span><br><span class="line">                JSONObject renewal = (JSONObject) renewals.get(p);</span><br><span class="line">                <span class="keyword">if</span> (originTransactionId.equals(renewal.getString(<span class="string">"original_transaction_id"</span>))) &#123;</span><br><span class="line">                    pendings.add(renewal);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            JSONObject renewal = (JSONObject) pendings.get(pendings.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> auto_renew_status = Integer.parseInt(renewal.getString(<span class="string">"auto_renew_status"</span>));<span class="comment">//自动续订订阅的当前续订状态。 “ 1”-订阅将在当前订阅期结束时续订。“ 0”-客户已关闭其订阅的自动续订。</span></span><br><span class="line">            <span class="keyword">if</span> (auto_renew_status == <span class="number">0</span>) &#123;<span class="comment">//用户有关闭订阅，重新订阅</span></span><br><span class="line">                user.setExpireTime(expiresTime);</span><br><span class="line">                user.setJoinTime(joinTime);</span><br><span class="line">                user.setType(<span class="number">1</span>);</span><br><span class="line">                iosPayment.setExpiresDate(expiresTime);</span><br><span class="line">                iosPayment.setPurchaseDate(<span class="keyword">new</span> Date(purchase_date));</span><br><span class="line">                log.info(<span class="string">"user id &#123;&#125; 重新订阅成功"</span>,user.getId());</span><br><span class="line">                <span class="keyword">return</span> sucribeSuccess(user, payload, transactionId, originTransactionId, type, localOrder, product, iosPayment);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (auto_renew_status == <span class="number">1</span>) &#123;<span class="comment">//对于扣费失败的用户, 苹果仍会尝试扣款60天, 解析 pending_renewal_info , auto_renew_status 为1并且 is_in_billing_retry_period 为1, 此时用户的状态并不能标记为已关闭, 而应该是扣费失败</span></span><br><span class="line">                String retry_period = renewal.getString(<span class="string">"is_in_billing_retry_period"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isEmpty(retry_period))&#123;<span class="comment">//沙盒测试时六次续订完关闭后再次重新订阅开始返回没有这个字段，只有auto_renew_status=1,再点击就有了（我也不知道为什么）</span></span><br><span class="line">                    <span class="keyword">if</span> (retry_period.equals(<span class="string">"1"</span>)) &#123;<span class="comment">//-App Store仍在尝试续订。</span></span><br><span class="line">                        <span class="keyword">return</span> ResultUtil.error(<span class="keyword">this</span>.i18n(<span class="string">"deduction.failed"</span>));<span class="comment">//扣费失败</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.error(<span class="keyword">this</span>.i18n(<span class="string">"subscribe.already"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Result&lt;Object&gt; <span class="title">sucribeSuccess</span><span class="params">(@CurrentUser User user, String payload, String transactionId, String originTraId, <span class="keyword">int</span> type, Order localOrder, Product product, IosPayment iosPayment)</span> </span>&#123;</span><br><span class="line">        userService.updateUser(user);</span><br><span class="line">        localOrder.setProduct(product);</span><br><span class="line">        localOrder.setTransactionId(transactionId);</span><br><span class="line">        localOrder.setType(type);</span><br><span class="line">        localOrder.setOriginTraId(originTraId);</span><br><span class="line">        localOrder.setStatus(Constant.PAY_SUCCESS);</span><br><span class="line">        orderService.updateOrder(localOrder);</span><br><span class="line">        iosPaymentService.update(iosPayment, payload, originTraId, product, IosPayment.Status.Completed);<span class="comment">//苹果支付详情</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setSuccessMsg(<span class="keyword">this</span>.i18n(<span class="string">"successfully"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Authorization</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/createOrder"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"创建本地订单"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;Object&gt; <span class="title">createOrder</span><span class="params">(@RequestBody Order order, @CurrentUser User user)</span> </span>&#123;</span><br><span class="line">        Order sysOrder = <span class="keyword">new</span> Order();</span><br><span class="line">        sysOrder.setQuantity(order.getQuantity());</span><br><span class="line">        sysOrder.setPayType(order.getPayType());</span><br><span class="line">        sysOrder.setMoney(order.getMoney());</span><br><span class="line">        sysOrder.setType(order.getType());</span><br><span class="line">        sysOrder.setUser(user);</span><br><span class="line">        sysOrder.setStatus(Constant.PAY_FAILURE);</span><br><span class="line">        String no = String.valueOf(System.currentTimeMillis());<span class="comment">//订单号</span></span><br><span class="line">        sysOrder.setNo(no + RandomUtil.getRandomNum());<span class="comment">//时间戳+随机六位数</span></span><br><span class="line">        orderRepository.save(sysOrder);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setData(sysOrder.getNo());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>是不是感觉苹果内购简单多啦<sup>_</sup>。例如我所做的业务是会员每月续费，那么会员到期日期的更新就在latest_receipt_info数组里比较最后一条订单数据（最新的订阅数据）的expiresDate和现在时间，如果大于现在时间就更新。<br>
关于自动连续订阅的有关问题，可以附上我的参考文章链接<a href="https://blog.csdn.net/theCrucian/article/details/89406203" target="_blank" rel="noopener">IAP 自动续费后端接入指南</a>和<a href="https://www.jianshu.com/p/abd2ba4deb54" target="_blank" rel="noopener">自动续期订阅总结</a>！</p>
<h2 id="Tips">Tips</h2>
<ul>
<li>iOS端传过来的苹果回调收据信息需base64加密，如果有严重呢个错误问题，注意收据信息的特殊符号替换，eg:&quot;%2B&quot;。</li>
<li>苹果内购订阅型验证服务器需多加共享密钥（由ios开发人员提供给你）验证,如果是添加的公共秘钥，那么消耗型验证也需要加上秘钥验证。</li>
<li>苹果在上线审核的时候也是使用沙盒账号测试的，那如何识别App端发过来的收据是沙盒测试还是正式环境用户的购买呢？这里服务端就要采用双重验证，即先把收据拿到正式环境的验证地址去验证，如果苹果的正式环境验证服务器返回的状态码 status 为 21007，则说明当前收据是沙盒环境产生，则再连接一次沙盒环境服务器进行验证，这样不管是我们自己采用沙盒账号测试还是苹果审核人员采用沙盒账号进行审核、或者用户购买都可以保证收据正常的验证成功。</li>
<li>苹果内购消耗型订单传过来的订单是在in_app数组里，而自动订阅型续订的最新数据都在latest_receipt_info数组里。</li>
</ul>
<h2 id="苹果内购自动连续订阅型注意点">苹果内购自动连续订阅型注意点</h2>
<ul>
<li>测试自动连续订阅型商品时，如果有免费使用期，每个沙盒账号只有一次免费试用期，且最多连续续订五次，一个月对应的测试时间是五分钟。</li>
<li>自动订阅类型正式环境，除了第一次购买行为是用户主动触发的。后续续费都是Apple自动完成的，一般在要过期的前24小时开始，苹果会尝试扣费。</li>
</ul>
<h2 id="服务器对自动连续订阅型产品续订的解决方案">服务器对自动连续订阅型产品续订的解决方案</h2>
<ol>
<li>添加server to server 通知</li>
</ol>
<ul>
<li>latest_expired_receipt_info	用于自动续订。过期订阅的收据的JSON表示形式.仅当通知类型为RENEWAL或CANCEL或订阅过期且续订失败时返回。<br>
项目集成请看官网有介绍。</li>
</ul>
<ol start="2">
<li>服务端server轮询要过期和过期的订单数据，主动向苹果服务器验证</li>
</ol>
]]></content>
      <categories>
        <category>第三方</category>
      </categories>
      <tags>
        <tag>第三方</tag>
        <tag>iOS内购</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot接入Google Play</title>
    <url>/2019/12/20/googlepay/</url>
    <content><![CDATA[<h2 id="撸代码前的准备工作">撸代码前的准备工作</h2>
<p>前阵子公司项目需要用到谷歌支付，开始接触的我懵懂摸索了一星期，终于和安卓对接好了谷歌支付。啥都不说了,直接上图：<br>
1.进入Google Play Console ,<a href="https://play.google.com/apps/publish/?account=7344212024493937034#AppListPlace" target="_blank" rel="noopener">https://play.google.com/apps/publish/?account=7344212024493937034#AppListPlace</a><br>
2.设置-&gt;API访问-&gt;创建oauth2客户端-&gt;关联刚创建的项目</p>
<a id="more"></a>
<p><img src="/images/googlepay01.png" alt=""><br>
3.可以创建服务账号<br>
<img src="/images/googlepay02.png" alt=""><br>
4.进入API和服务-&gt;设置认证信息和oauth2统一画面<br>
<img src="/images/googlepay03.png" alt=""><br>
认证信息<br>
<img src="/images/googlepay04.png" alt=""><br>
oauth2同意画面<br>
<img src="/images/googlepay05.png" alt=""><br>
<img src="/images/googlepay07.png" alt=""><br>
5.可以点击项目选择创建oauth2客户端 或者服务帐号<br>
<img src="/images/googlepay08.png" alt=""><br>
6.下载oauth2客户端json或进入管理账户下载账户的secret.json或p12文件<br>
<img src="/images/googlepay09.png" alt=""><br>
基本的控制台设置流程就是这了，接下来再看代码部分：</p>
<h2 id="代码部分">代码部分</h2>
<p>1.先在application.yml配置google账号的信息，如下图<br>
<img src="/images/googlepay10.png" alt=""><br>
注意：服务器谷歌支付验证有两种方式：1请求googleapi验证 2.使用公密钥验证。在这里我使用的是第一种方式请求google api验证，第二种我也写了 但是不怎么好使<sup>_</sup>，在这里我也附上代码。。。<br>
google配置类<code>GooglePayConfig.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xy.goone.config.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xy.goone.common.util.pay.GooglePayVerifyUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fumei.jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-09-24 15:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"app.google.config"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GooglePayConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String keyFile;</span><br><span class="line">    <span class="keyword">private</span> String pkcs;</span><br><span class="line">    <span class="keyword">private</span> String serviceAccountEmail;</span><br><span class="line">    <span class="keyword">private</span> String client_id;</span><br><span class="line">    <span class="keyword">private</span> String client_secret;</span><br><span class="line">    <span class="keyword">private</span> String refresh_token;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKeyFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyFile</span><span class="params">(String keyFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyFile = keyFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPkcs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pkcs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPkcs</span><span class="params">(String pkcs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pkcs = pkcs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServiceAccountEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serviceAccountEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceAccountEmail</span><span class="params">(String serviceAccountEmail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceAccountEmail = serviceAccountEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKeylongString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GooglePayVerifyUtil.load(<span class="keyword">this</span>.getKeyFile());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPkcslongString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> GooglePayVerifyUtil.load(<span class="keyword">this</span>.getPkcs());&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClient_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClient_id</span><span class="params">(String client_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client_id = client_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClient_secret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client_secret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClient_secret</span><span class="params">(String client_secret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client_secret = client_secret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRefresh_token</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> refresh_token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRefresh_token</span><span class="params">(String refresh_token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.refresh_token = refresh_token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证工具类<code>GooglePayVerifyUtil.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xy.goone.common.util.pay;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"><span class="keyword">import</span> java.security.Signature;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fumei.jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-07 16:14</span></span><br><span class="line"><span class="comment"> * 谷歌支付</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GooglePayVerifyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Value(value = "$&#123;google.p12key&#125;")</span></span><br><span class="line"><span class="comment">    private String p12;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Value(value = "$&#123;google.email&#125;")</span></span><br><span class="line"><span class="comment">    private String email;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Value("$&#123;google.packageName&#125;")</span></span><br><span class="line"><span class="comment">    private String packageName;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static void main(String[] args) throws Exception &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        HttpTransport transport = GoogleNetHttpTransport.newTrustedTransport();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        PrivateKey privateKey = SecurityUtils.loadPrivateKeyFromKeyStore(</span></span><br><span class="line"><span class="comment">                SecurityUtils.getPkcs12KeyStore(),</span></span><br><span class="line"><span class="comment">                new FileInputStream(new File("&#123;P12 key file&#125;")), // 生成的P12文件</span></span><br><span class="line"><span class="comment">                "notasecret", "privatekey", "notasecret");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        GoogleCredential credential = new GoogleCredential.Builder()</span></span><br><span class="line"><span class="comment">                .setTransport(transport).setJsonFactory(JacksonFactory.getDefaultInstance())</span></span><br><span class="line"><span class="comment">                .setServiceAccountId("&#123;Email address&#125;") // e.g.: 626891557797-frclnjv31rn4ss81ch746g9t6pd3mmej@developer.gserviceaccount.com</span></span><br><span class="line"><span class="comment">                .setServiceAccountScopes(AndroidPublisherScopes.all())</span></span><br><span class="line"><span class="comment">                .setServiceAccountPrivateKey(privateKey).build();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        AndroidPublisher publisher = new AndroidPublisher.Builder(transport,</span></span><br><span class="line"><span class="comment">                JacksonFactory.getDefaultInstance(), credential).build();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        AndroidPublisher.Purchases.Products products = publisher.purchases().products();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 参数详细说明: https://developers.google.com/android-publisher/api-ref/purchases/products/get</span></span><br><span class="line"><span class="comment">        AndroidPublisher.Purchases.Products.Get product = products.get("&#123;packageName&#125;",</span></span><br><span class="line"><span class="comment">                "&#123;productId&#125;", "&#123;token&#125;");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 获取订单信息</span></span><br><span class="line"><span class="comment">        // 返回信息说明: https://developers.google.com/android-publisher/api-ref/purchases/products</span></span><br><span class="line"><span class="comment">        // 通过consumptionState, purchaseState可以判断订单的状态</span></span><br><span class="line"><span class="comment">        ProductPurchase purchase = product.execute();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">docheck</span><span class="params">(String content, String sign, String publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encodedKey = Base64.decodeBase64(publicKey);</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(encodedKey));</span><br><span class="line">        Signature signature = Signature.getInstance(<span class="string">"SHA1WithRSA"</span>);</span><br><span class="line">        signature.initVerify(pubKey);</span><br><span class="line">        signature.update(content.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="keyword">return</span> signature.verify(Base64.decodeBase64(sign));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String PRIVATE_KEYS;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> String <span class="title">load</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PRIVATE_KEYS == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                file = GooglePayVerifyUtil.class.getResource("/").getFile() + File.separator + file;</span><br><span class="line">            &#125;</span><br><span class="line">            File f = <span class="keyword">new</span> File(file);</span><br><span class="line">            <span class="keyword">try</span> (InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(f), <span class="string">"utf8"</span>);) &#123;</span><br><span class="line">                StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">char</span>[] bf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> size = reader.read(bf);</span><br><span class="line">                    <span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    buffer.append(bf, <span class="number">0</span>, size);</span><br><span class="line">                &#125;</span><br><span class="line">                PRIVATE_KEYS = buffer.toString();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"read file error ! "</span> + f.getAbsolutePath(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> PRIVATE_KEYS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OrderController.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; cacheToken = <span class="keyword">null</span>;<span class="comment">//设置静态变量，用于判断access_token是否过期</span></span><br><span class="line"> <span class="meta">@Authorization</span></span><br><span class="line"> <span class="meta">@PostMapping</span>(value = <span class="string">"/createOrder"</span>)</span><br><span class="line"> <span class="meta">@ApiOperation</span>(value = <span class="string">"创建本地订单"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Result&lt;Object&gt; <span class="title">createOrder</span><span class="params">(@RequestBody Order order, @CurrentUser User user)</span> </span>&#123;</span><br><span class="line">     Order sysOrder = <span class="keyword">new</span> Order();</span><br><span class="line">     sysOrder.setQuantity(order.getQuantity());</span><br><span class="line">     sysOrder.setPayType(order.getPayType());</span><br><span class="line">     sysOrder.setMoney(order.getMoney());</span><br><span class="line">     sysOrder.setType(order.getType());</span><br><span class="line">     sysOrder.setUser(user);</span><br><span class="line">     sysOrder.setStatus(Constant.PAY_FAILURE);</span><br><span class="line">     String no = String.valueOf(System.currentTimeMillis());<span class="comment">//订单号</span></span><br><span class="line">     sysOrder.setNo(no + RandomUtil.getRandomNum());<span class="comment">//时间戳+随机六位数</span></span><br><span class="line">     orderRepository.save(sysOrder);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setData(sysOrder.getNo());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/googlePayVerify"</span>, method = RequestMethod.POST)</span><br><span class="line"> <span class="meta">@ApiOperation</span>(value = <span class="string">"谷歌支付方式二：通过请求谷歌api验证"</span>)</span><br><span class="line"> <span class="meta">@Authorization</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Result&lt;Object&gt; <span class="title">googlePlayVerify</span><span class="params">(@RequestBody Pay.Payment payment, @CurrentUser User user)</span> </span>&#123;</span><br><span class="line">     String no = payment.getNo();</span><br><span class="line">     <span class="keyword">int</span> type = payment.getType();<span class="comment">//类型：0 消耗 1购买</span></span><br><span class="line">     Pay.Purchase receipt = payment.getPurchase();</span><br><span class="line">     <span class="comment">//先校对与本地订单</span></span><br><span class="line">     Order localOrder = orderRepository.findByNo(no);<span class="comment">//禁止重复刷单</span></span><br><span class="line">     log.info(<span class="string">"no is &#123;&#125;"</span>, no);</span><br><span class="line">     <span class="keyword">if</span> (localOrder == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setErrorMsg(<span class="keyword">this</span>.i18n(<span class="string">"order.does.not.exist.and.recharge.failed"</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (localOrder.getStatus() == Constant.PAY_SUCCESS) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setErrorMsg(<span class="keyword">this</span>.i18n(<span class="string">"this.order.has.been.successfully.recharged.and.cannot.be.refilled"</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     JSONObject jsonObject = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         String json = JsonUtil.objectToJson(receipt);</span><br><span class="line">         log.info(<span class="string">"param  purchase json is &#123;&#125;"</span>, json);</span><br><span class="line">         jsonObject = JSON.parseObject(json);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> HttpRequestException.newI18N(<span class="string">"data.parsing.failed"</span>);<span class="comment">//数据解析失败</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">null</span> != cacheToken) &#123;</span><br><span class="line">         Long expires_in = Long.valueOf(cacheToken.get(<span class="string">"expires_in"</span>)); <span class="comment">// 有效时长</span></span><br><span class="line">         Long create_time = Long.valueOf(cacheToken.get(<span class="string">"create_time"</span>)); <span class="comment">// access_token的创建时间</span></span><br><span class="line">         Long now_time = (<span class="keyword">new</span> Date().getTime()) / <span class="number">1000</span>;</span><br><span class="line">         <span class="keyword">if</span> (now_time &gt; (create_time + expires_in - <span class="number">300</span>)) &#123; <span class="comment">// 提前五分钟重新获取access_token</span></span><br><span class="line">             cacheToken = getAccessToken();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         cacheToken = getAccessToken();</span><br><span class="line">     &#125;</span><br><span class="line">     String access_token = cacheToken.get(<span class="string">"access_token"</span>);</span><br><span class="line">     String productId = jsonObject.getString(<span class="string">"productId"</span>);</span><br><span class="line">     String packageName = jsonObject.getString(<span class="string">"packageName"</span>);</span><br><span class="line">     String purchaseToken = jsonObject.getString(<span class="string">"purchaseToken"</span>);</span><br><span class="line">     <span class="keyword">int</span> purchaseState = jsonObject.getIntValue(<span class="string">"purchaseState"</span>);</span><br><span class="line">     <span class="keyword">long</span> purchaseTime = jsonObject.getLongValue(<span class="string">"purchaseTime"</span>);</span><br><span class="line">     String orderId = jsonObject.getString(<span class="string">"orderId"</span>);</span><br><span class="line">     log.info(<span class="string">"access_token:&#123;&#125;,productId:&#123;&#125;,packageName:&#123;&#125;,purchaseToken:&#123;&#125;,purchaseState:&#123;&#125;,orderId:&#123;&#125;"</span>, access_token, productId, packageName, purchaseToken, purchaseState, orderId);</span><br><span class="line">     GooglePayment googlePayment = googlePaymentService.save(no, orderId, access_token, productId, packageName, purchaseToken, purchaseState, user, purchaseTime);</span><br><span class="line">     Order go = orderRepository.findByTransactionId(orderId);</span><br><span class="line">     <span class="keyword">if</span> (go != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> HttpRequestException.newI18N(<span class="string">"this.order.has.been.successfully.recharged.and.cannot.be.refilled"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> String client_id = googlePayConfig.getClient_id();</span><br><span class="line">         <span class="keyword">final</span> String client_secret = googlePayConfig.getClient_secret();</span><br><span class="line">         <span class="keyword">final</span> String refresh_token = googlePayConfig.getRefresh_token();</span><br><span class="line">         HttpTransport transport = GoogleNetHttpTransport.newTrustedTransport();</span><br><span class="line">         TokenResponse tokenResponse = <span class="keyword">new</span> TokenResponse();</span><br><span class="line">         tokenResponse.setAccessToken(access_token);</span><br><span class="line">         tokenResponse.setRefreshToken(refresh_token);</span><br><span class="line">         tokenResponse.setExpiresInSeconds(<span class="number">3600L</span>);</span><br><span class="line">         tokenResponse.setTokenType(<span class="string">"Bearer"</span>);</span><br><span class="line">         GoogleCredential credential = <span class="keyword">new</span> GoogleCredential.Builder()</span><br><span class="line">                 .setTransport(transport)</span><br><span class="line">                 .setJsonFactory(JacksonFactory.getDefaultInstance())</span><br><span class="line">                 .setClientSecrets(client_id, client_secret)</span><br><span class="line">                 .build()</span><br><span class="line">                 .setFromTokenResponse(tokenResponse);</span><br><span class="line">         AndroidPublisher publisher = <span class="keyword">new</span> AndroidPublisher.Builder(transport, JacksonFactory.getDefaultInstance(), credential).setApplicationName(packageName).build();</span><br><span class="line">         <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;<span class="comment">//订阅型</span></span><br><span class="line">             <span class="comment">//谷歌订阅周期为一个月续订 测试账号对应时间为5分钟 且测试账号最多可连续订阅6次</span></span><br><span class="line">             <span class="keyword">return</span> googleSubscribe(user, type, localOrder, productId, packageName, purchaseToken, orderId, publisher, googlePayment);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         AndroidPublisher.Purchases.Products products = publisher.purchases().products();</span><br><span class="line">         AndroidPublisher.Purchases.Products.Get product = products.get(packageName, productId, purchaseToken);<span class="comment">//消耗型验证</span></span><br><span class="line">         log.info(<span class="string">"product,packageName:&#123;&#125;,productId:&#123;&#125;,token:&#123;&#125;"</span>, product.getPackageName(), product.getProductId(), product.getToken());</span><br><span class="line">         ProductPurchase purchase = product.execute();</span><br><span class="line">         log.info(<span class="string">"purchase:&#123;&#125;"</span>, purchase);</span><br><span class="line">         <span class="keyword">if</span> (purchase.getPurchaseState() == <span class="number">0</span>) &#123;<span class="comment">//确认状态为已购买状态</span></span><br><span class="line">             <span class="comment">//POST https://www.googleapis.com/androidpublisher/v3/applications/packageName/purchases/products/productId/tokens/token:acknowledge</span></span><br><span class="line">             Product pro = productService.getByProductId(productId).orElseThrow(() -&gt; &#123;</span><br><span class="line">                 <span class="keyword">return</span> HttpRequestException.newI18N(<span class="string">"not.find.product"</span>);</span><br><span class="line">             &#125;);</span><br><span class="line">             <span class="keyword">int</span> amount = pro.getAmount();</span><br><span class="line">             <span class="keyword">int</span> coin = user.getCoin() + amount;</span><br><span class="line">             user.setCoin(coin);</span><br><span class="line">             userService.updateUser(user);<span class="comment">//更新用户coin</span></span><br><span class="line">             log.info(<span class="string">"产品的确认状态:&#123;&#125;"</span>, purchase.getAcknowledgementState());</span><br><span class="line">             <span class="keyword">if</span> (purchase.getAcknowledgementState() == <span class="number">0</span>) &#123;<span class="comment">//尚未得到确认</span></span><br><span class="line">                 ProductPurchasesAcknowledgeRequest productPurchasesAcknowledgeRequest = <span class="keyword">new</span> ProductPurchasesAcknowledgeRequest();</span><br><span class="line">                 productPurchasesAcknowledgeRequest.setDeveloperPayload(purchase.getDeveloperPayload());</span><br><span class="line">                 AndroidPublisher.Purchases.Products.Acknowledge acknowledge = products.acknowledge(packageName, productId, purchaseToken, productPurchasesAcknowledgeRequest);</span><br><span class="line">                 acknowledge.execute();</span><br><span class="line">             &#125;</span><br><span class="line">             localOrder.setTransactionId(orderId);</span><br><span class="line">             localOrder.setStatus(Constant.PAY_SUCCESS);</span><br><span class="line">             localOrder.setProduct(pro);</span><br><span class="line">             localOrder.setQuantity(pro.getAmount());</span><br><span class="line">             localOrder.setType(type);<span class="comment">//消耗型</span></span><br><span class="line">             orderService.updateOrder(localOrder);</span><br><span class="line">             billRecordService.save(amount, <span class="number">1</span>, <span class="string">"ポイント購入"</span>, user);</span><br><span class="line">             googlePayment.setAcknowledged(<span class="number">1</span>);</span><br><span class="line">             googlePaymentService.update(googlePayment, pro, GooglePayment.Type.Consume);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setData(coin);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">"exception is &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> HttpRequestException.newI18N(<span class="string">"order.verification"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setErrorMsg(<span class="keyword">this</span>.i18n(<span class="string">"order.verification"</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Result&lt;Object&gt; <span class="title">googleSubscribe</span><span class="params">(@CurrentUser User user, <span class="keyword">int</span> type, Order localOrder, String productId, String packageName, String purchaseToken, String orderId, AndroidPublisher publisher, GooglePayment googlePayment)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     log.info(<span class="string">"订阅验证开始......"</span>);</span><br><span class="line">     AndroidPublisher.Purchases.Subscriptions subscriptions = publisher.purchases().subscriptions();</span><br><span class="line">     AndroidPublisher.Purchases.Subscriptions.Get subscription = subscriptions.get(packageName, productId, purchaseToken);</span><br><span class="line">     SubscriptionPurchase subscriptionPurchase = subscription.execute();</span><br><span class="line">     log.info(<span class="string">"subscriptionPurchase:&#123;&#125;"</span>, subscriptionPurchase);</span><br><span class="line">     <span class="keyword">long</span> expiryTimeMillis = subscriptionPurchase.getExpiryTimeMillis();<span class="comment">//订阅到期的时间</span></span><br><span class="line">     <span class="keyword">long</span> startTimeMillis = subscriptionPurchase.getStartTimeMillis();<span class="comment">//授予订阅的时间</span></span><br><span class="line">     <span class="keyword">boolean</span> autoRenewing = subscriptionPurchase.getAutoRenewing();<span class="comment">//订阅在达到其当前到期时间时是否将自动续订。</span></span><br><span class="line">     <span class="keyword">int</span> paymentState = subscriptionPurchase.getPaymentState();<span class="comment">//订阅的付款状态： 0付款等待中 1已收到付款 2免费试用 3待推迟的升级</span></span><br><span class="line">     log.info(<span class="string">"expiryTimeMillis : &#123;&#125;,startTimeMillis : &#123;&#125;,autoRenewing : &#123;&#125;,paymentState : &#123;&#125;,productId:&#123;&#125;,acknowledgementState:&#123;&#125;"</span>, expiryTimeMillis, startTimeMillis, autoRenewing, paymentState, productId, subscriptionPurchase.getAcknowledgementState());</span><br><span class="line">     Product pro = productService.getByProductId(productId).orElseThrow(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">return</span> HttpRequestException.newI18N(<span class="string">"not.find.product"</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">     user.setJoinTime(<span class="keyword">new</span> Date(startTimeMillis));<span class="comment">//会员订阅时间</span></span><br><span class="line">     user.setExpireTime(<span class="keyword">new</span> Date(expiryTimeMillis));<span class="comment">//会员到期时间</span></span><br><span class="line">     <span class="keyword">if</span> (paymentState == <span class="number">1</span> || paymentState == <span class="number">2</span>) &#123;<span class="comment">//付款状态或者是处于试用期  1已收到付款  2免费试用</span></span><br><span class="line">         user.setType(<span class="number">1</span>);<span class="comment">//强者会员</span></span><br><span class="line">     &#125;</span><br><span class="line">     userService.updateUser(user);</span><br><span class="line">     log.info(<span class="string">"joinTime is&#123;&#125;,expireTime is &#123;&#125;"</span>, user.getJoinTime(), user.getExpireTime());</span><br><span class="line">     <span class="keyword">if</span> (subscriptionPurchase.getAcknowledgementState() == <span class="number">0</span>) &#123;<span class="comment">//尚未得到确认</span></span><br><span class="line">         log.info(<span class="string">"确认订阅订单。。。。"</span>);</span><br><span class="line">         SubscriptionPurchasesAcknowledgeRequest subAckRe = <span class="keyword">new</span> SubscriptionPurchasesAcknowledgeRequest();</span><br><span class="line">         subAckRe.setDeveloperPayload(subscriptionPurchase.getDeveloperPayload());</span><br><span class="line">         AndroidPublisher.Purchases.Subscriptions.Acknowledge subAck = subscriptions.acknowledge(packageName, productId, purchaseToken, subAckRe);</span><br><span class="line">         subAck.execute();</span><br><span class="line">     &#125;</span><br><span class="line">     localOrder.setTransactionId(orderId);</span><br><span class="line">     localOrder.setStatus(<span class="number">1</span>);</span><br><span class="line">     localOrder.setProduct(pro);</span><br><span class="line">     localOrder.setType(type);<span class="comment">//订阅</span></span><br><span class="line">     orderService.updateOrder(localOrder);</span><br><span class="line">     googlePayment.setAcknowledged(<span class="number">1</span>);</span><br><span class="line">     googlePayment.setPurchaseTime(<span class="keyword">new</span> Date(startTimeMillis));</span><br><span class="line">     googlePayment.setExpiresDate(<span class="keyword">new</span> Date(expiryTimeMillis));</span><br><span class="line">     googlePaymentService.update(googlePayment, pro, GooglePayment.Type.SubScribe);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ResultUtil&lt;&gt;().setSuccessMsg(<span class="keyword">this</span>.i18n(<span class="string">"successfully"</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RequestMapping</span>(value = <span class="string">"/googleCancel"</span>, method = RequestMethod.POST)</span><br><span class="line"> <span class="meta">@ApiOperation</span>(value = <span class="string">"/取消订阅"</span>)</span><br><span class="line"> <span class="meta">@Authorization</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Result&lt;Object&gt; <span class="title">cancel</span><span class="params">(@RequestBody Pay.Purchase cancel, @CurrentUser User user)</span> </span>&#123;</span><br><span class="line">     String packageName = cancel.getPackageName();</span><br><span class="line">     String productId = cancel.getProductId();</span><br><span class="line">     String purchaseToken = cancel.getPurchaseToken();</span><br><span class="line">     log.info(<span class="string">"谷歌取消订阅传参,packageName is &#123;&#125;,productId is &#123;&#125;,purchaseToken is &#123;&#125;"</span>, packageName, productId, purchaseToken);</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">null</span> != cacheToken) &#123;</span><br><span class="line">         Long expires_in = Long.valueOf(cacheToken.get(<span class="string">"expires_in"</span>)); <span class="comment">// 有效时长</span></span><br><span class="line">         Long create_time = Long.valueOf(cacheToken.get(<span class="string">"create_time"</span>)); <span class="comment">// access_token的创建时间</span></span><br><span class="line">         Long now_time = (<span class="keyword">new</span> Date().getTime()) / <span class="number">1000</span>;</span><br><span class="line">         <span class="keyword">if</span> (now_time &gt; (create_time + expires_in - <span class="number">300</span>)) &#123; <span class="comment">// 提前五分钟重新获取access_token</span></span><br><span class="line">             cacheToken = getAccessToken();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         cacheToken = getAccessToken();</span><br><span class="line">     &#125;</span><br><span class="line">     String access_token = cacheToken.get(<span class="string">"access_token"</span>);</span><br><span class="line">     log.info(<span class="string">"accessToken is &#123;&#125;"</span>, access_token);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> String client_id = googlePayConfig.getClient_id();</span><br><span class="line">         <span class="keyword">final</span> String client_secret = googlePayConfig.getClient_secret();</span><br><span class="line">         <span class="keyword">final</span> String refresh_token = googlePayConfig.getRefresh_token();</span><br><span class="line">         HttpTransport transport = GoogleNetHttpTransport.newTrustedTransport();</span><br><span class="line">         TokenResponse tokenResponse = <span class="keyword">new</span> TokenResponse();</span><br><span class="line">         tokenResponse.setAccessToken(access_token);</span><br><span class="line">         tokenResponse.setRefreshToken(refresh_token);</span><br><span class="line">         tokenResponse.setExpiresInSeconds(<span class="number">3600L</span>);</span><br><span class="line">         tokenResponse.setTokenType(<span class="string">"Bearer"</span>);</span><br><span class="line">         GoogleCredential credential = <span class="keyword">new</span> GoogleCredential.Builder()</span><br><span class="line">                 .setTransport(transport)</span><br><span class="line">                 .setJsonFactory(JacksonFactory.getDefaultInstance())</span><br><span class="line">                 .setClientSecrets(client_id, client_secret)</span><br><span class="line">                 .build()</span><br><span class="line">                 .setFromTokenResponse(tokenResponse);</span><br><span class="line">         AndroidPublisher publisher = <span class="keyword">new</span> AndroidPublisher.Builder(transport, JacksonFactory.getDefaultInstance(), credential).setApplicationName(packageName).build();</span><br><span class="line"></span><br><span class="line">         AndroidPublisher.Purchases.Subscriptions subscriptions = publisher.purchases().subscriptions();</span><br><span class="line">         AndroidPublisher.Purchases.Subscriptions.Get subscription = subscriptions.get(packageName, productId, purchaseToken);</span><br><span class="line">         SubscriptionPurchase subscriptionPurchase = subscription.execute();</span><br><span class="line">         log.info(<span class="string">"取消订阅的的订阅信息为&#123;&#125;"</span>, subscriptionPurchase);</span><br><span class="line">         SubscriptionPurchasesAcknowledgeRequest subAckRe = <span class="keyword">new</span> SubscriptionPurchasesAcknowledgeRequest();</span><br><span class="line">         subAckRe.setDeveloperPayload(subscriptionPurchase.getDeveloperPayload());</span><br><span class="line">         AndroidPublisher.Purchases.Subscriptions.Cancel cancelSub = subscriptions.cancel(packageName, productId, purchaseToken);</span><br><span class="line">         cancelSub.execute();</span><br><span class="line">         log.info(<span class="string">"取消谷歌订阅成功"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">"exception is &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> HttpRequestException.newI18N(<span class="string">"order.verification"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ResultUtil.success(<span class="keyword">this</span>.i18n(<span class="string">"successfully"</span>));</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*   @RequestMapping(value = "/googlePay", method = RequestMethod.POST)</span></span><br><span class="line"><span class="comment">    @ApiOperation(value = "谷歌支付方式二：通过请求谷歌api验证")</span></span><br><span class="line"><span class="comment">    @Authorization</span></span><br><span class="line"><span class="comment">    public Result&lt;Object&gt; googlePlay(@RequestBody Pay.Payment payment, @CurrentUser User user) &#123;</span></span><br><span class="line"><span class="comment">        String no = payment.getNo();</span></span><br><span class="line"><span class="comment">        Pay.Purchase receipt = payment.getPurchase();</span></span><br><span class="line"><span class="comment">        //先校对与本地订单</span></span><br><span class="line"><span class="comment">        Order localOrder = orderRepository.findByNo(no);//禁止重复刷单</span></span><br><span class="line"><span class="comment">        if (localOrder == null) &#123;</span></span><br><span class="line"><span class="comment">            return new ResultUtil&lt;&gt;().setErrorMsg(this.i18n("order.does.not.exist.and.recharge.failed"));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        JSONObject jsonObject = null;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            String json = JsonUtil.objectToJson(receipt);</span></span><br><span class="line"><span class="comment">            jsonObject = JSON.parseObject(json);</span></span><br><span class="line"><span class="comment">        &#125; catch (JSONException e) &#123;</span></span><br><span class="line"><span class="comment">            throw new HttpRequestException(HttpServletResponse.SC_NOT_ACCEPTABLE, this.i18n("data.parsing.failed"));//数据解析失败</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        String productId = jsonObject.getString("productId");</span></span><br><span class="line"><span class="comment">        String packageName = jsonObject.getString("packageName");</span></span><br><span class="line"><span class="comment">        String purchaseToken = jsonObject.getString("purchaseToken");</span></span><br><span class="line"><span class="comment">        int purchaseState = jsonObject.getIntValue("purchaseState");</span></span><br><span class="line"><span class="comment">        String orderId = jsonObject.getString("orderId");</span></span><br><span class="line"><span class="comment">        log.info("productId:&#123;&#125;,packageName:&#123;&#125;,purchaseToken:&#123;&#125;,purchaseState:&#123;&#125;,orderId:&#123;&#125;",productId,packageName,purchaseToken,purchaseState,orderId);</span></span><br><span class="line"><span class="comment">        Order go = orderRepository.findByTransactionId(orderId);</span></span><br><span class="line"><span class="comment">        if (go!=null)&#123;</span></span><br><span class="line"><span class="comment">            throw new HttpRequestException(HttpServletResponse.SC_NOT_ACCEPTABLE,this.i18n("this.order.has.been.successfully.recharged.and.cannot.be.refilled"));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            File file = ResourceUtils.getFile("classpath:/googlePlayKey/rizin_p12.p12");</span></span><br><span class="line"><span class="comment">            HttpTransport transport = GoogleNetHttpTransport.newTrustedTransport();</span></span><br><span class="line"><span class="comment">            PrivateKey privateKey = SecurityUtils.loadPrivateKeyFromKeyStore(</span></span><br><span class="line"><span class="comment">                    SecurityUtils.getPkcs12KeyStore(),</span></span><br><span class="line"><span class="comment">                    new FileInputStream(file), // 生成的P12文件</span></span><br><span class="line"><span class="comment">                    "notasecret", "privatekey", "notasecret");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            GoogleCredential credential = new GoogleCredential.Builder()</span></span><br><span class="line"><span class="comment">                    .setTransport(transport).setJsonFactory(JacksonFactory.getDefaultInstance())</span></span><br><span class="line"><span class="comment">                    .setServiceAccountId(googlePayConfig.getServiceAccountEmail()) // e.g.: 626891557797-frclnjv31rn4ss81ch746g9t6pd3mmej@developer.gserviceaccount.com</span></span><br><span class="line"><span class="comment">                    .setServiceAccountScopes(AndroidPublisherScopes.all())</span></span><br><span class="line"><span class="comment">                    .setServiceAccountPrivateKey(privateKey).build();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            AndroidPublisher publisher = new AndroidPublisher.Builder(transport,</span></span><br><span class="line"><span class="comment">                    JacksonFactory.getDefaultInstance(), credential).build();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            AndroidPublisher.Purchases.Products products = publisher.purchases().products();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // 参数详细说明: https://developers.google.com/android-publisher/api-ref/purchases/products/get</span></span><br><span class="line"><span class="comment">            AndroidPublisher.Purchases.Products.Get product = products.get(packageName,</span></span><br><span class="line"><span class="comment">                    productId, purchaseToken);</span></span><br><span class="line"><span class="comment">            log.info("credential:&#123;&#125;,publisher:&#123;&#125;,products:&#123;&#125;,product:&#123;&#125;",credential,publisher,products,product);</span></span><br><span class="line"><span class="comment">            // 获取订单信息</span></span><br><span class="line"><span class="comment">            // 返回信息说明: https://developers.google.com/android-publisher/api-ref/purchases/products</span></span><br><span class="line"><span class="comment">            // 通过consumptionState, purchaseState可以判断订单的状态</span></span><br><span class="line"><span class="comment">            ProductPurchase purchase = product.execute();</span></span><br><span class="line"><span class="comment">            log.info("purchaseis : &#123;&#125;",purchase);</span></span><br><span class="line"><span class="comment">            if (purchase.getPurchaseState()==0) &#123;</span></span><br><span class="line"><span class="comment">                Product pro = productService.getByProductId(productId);</span></span><br><span class="line"><span class="comment">                int amount = pro.getAmount();</span></span><br><span class="line"><span class="comment">                BigDecimal price = pro.getPrice();</span></span><br><span class="line"><span class="comment">                int coin = user.getCoin() + amount;</span></span><br><span class="line"><span class="comment">                user.setCoin(coin);</span></span><br><span class="line"><span class="comment">                userService.updateUser(user);//更新用户coin</span></span><br><span class="line"><span class="comment">                localOrder.setTransactionId(orderId);</span></span><br><span class="line"><span class="comment">                localOrder.setStatus(1);</span></span><br><span class="line"><span class="comment">                //todo::充值类型是消耗型还是订阅型 type赋值</span></span><br><span class="line"><span class="comment">                localOrder.setProductId(pro.getId());</span></span><br><span class="line"><span class="comment">                orderService.updateOrder(localOrder);</span></span><br><span class="line"><span class="comment">                return new ResultUtil&lt;&gt;().setData(coin);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">            throw new HttpRequestException(HttpServletResponse.SC_NOT_ACCEPTABLE, this.i18n("order.verification"));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return new ResultUtil&lt;&gt;().setErrorMsg(this.i18n("order.verification"));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getAccessToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     String client_id = googlePayConfig.getClient_id();</span><br><span class="line">     String client_secret = googlePayConfig.getClient_secret();</span><br><span class="line">     String refresh_token = googlePayConfig.getRefresh_token();</span><br><span class="line">     Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     Map&lt;String, String&gt; querys = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     Map&lt;String, String&gt; map = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// HTTP 获取access_token</span></span><br><span class="line">         String url = <span class="string">"https://accounts.google.com/o/oauth2/token"</span>;</span><br><span class="line">         headers.put(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded; charset=utf-8"</span>);</span><br><span class="line">         headers.put(<span class="string">"Accept"</span>, <span class="string">"text/plain;charset=utf-8"</span>);</span><br><span class="line">         querys.put(<span class="string">"grant_type"</span>, <span class="string">"refresh_token"</span>);</span><br><span class="line">         querys.put(<span class="string">"client_id"</span>, client_id);</span><br><span class="line">         querys.put(<span class="string">"client_secret"</span>, client_secret);</span><br><span class="line">         querys.put(<span class="string">"refresh_token"</span>, refresh_token);</span><br><span class="line">         String googleAccessToken = HttpUtils.send(url, headers, querys, <span class="string">"UTF-8"</span>);</span><br><span class="line">         JSONObject tokenObject = JSON.parseObject(googleAccessToken);</span><br><span class="line">         String access_token = tokenObject.getString(<span class="string">"access_token"</span>);</span><br><span class="line">         Long expires_in = tokenObject.getLong(<span class="string">"expires_in"</span>);</span><br><span class="line">         map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">         map.put(<span class="string">"access_token"</span>, access_token);</span><br><span class="line">         map.put(<span class="string">"expires_in"</span>, String.valueOf(expires_in));</span><br><span class="line">         <span class="comment">// 带入access_token的创建时间，用于之后判断是否失效</span></span><br><span class="line">         map.put(<span class="string">"create_time"</span>, String.valueOf((<span class="keyword">new</span> Date().getTime()) / <span class="number">1000</span>));</span><br><span class="line">         log.info(<span class="string">"包含access_token的JSON信息为: &#123;&#125;"</span>, tokenObject);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">         log.error(<span class="string">"获取access_token失败,原因是:&#123;&#125;"</span>, e);</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         log.error(<span class="string">"获取access_token失败,原因是:&#123;&#125;"</span>, e);</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>Pay.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xy.goone.modules.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fumei.jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-05 16:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> type;<span class="comment">//类型：0消耗 1订阅</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String no;<span class="comment">//本地订单号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Purchase purchase;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Payment</span><span class="params">(<span class="keyword">int</span> type, String no, Purchase purchase)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">            <span class="keyword">this</span>.no = no;</span><br><span class="line">            <span class="keyword">this</span>.purchase = purchase;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(String no)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.no = no;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Purchase <span class="title">getPurchase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> purchase;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPurchase</span><span class="params">(Purchase purchase)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.purchase = purchase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Purchase</span> </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> String productId;</span><br><span class="line">         <span class="keyword">private</span> String purchaseToken;</span><br><span class="line">         <span class="keyword">private</span> String purchaseState;</span><br><span class="line">         <span class="keyword">private</span> String packageName;</span><br><span class="line">         <span class="keyword">private</span> String orderId;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">boolean</span> acknowledged;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getPurchaseToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> purchaseToken;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPurchaseToken</span><span class="params">(String purchaseToken)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.purchaseToken = purchaseToken;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getPurchaseState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> purchaseState;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPurchaseState</span><span class="params">(String purchaseState)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.purchaseState = purchaseState;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getPackageName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> packageName;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPackageName</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.packageName = packageName;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> orderId;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getProductId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> productId;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductId</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.productId = productId;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAcknowledged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> acknowledged;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAcknowledged</span><span class="params">(<span class="keyword">boolean</span> acknowledged)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.acknowledged = acknowledged;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>好啦，基本代码差不多就是这些了。在对接过程中，我又几点要提示的。</p>
<h2 id="Tips">Tips</h2>
<ul>
<li>谷歌测试账号下单五分钟内没有任何操作比如验证确认消耗就会自动取消该订单，消耗型的产品需在三天内确认订单，否则此订单无效。</li>
<li>确认订单可以在服务端或客户端进行，但是消耗型商品需要进行消耗(订阅型商品不需要进行消耗),服务端只能确认不能消耗产品，验证并确认完毕的产品需要客户端进行消耗，否则下次购买时将不允许再次购买。</li>
<li>谷歌支付生产订阅和测试订阅的周期不同，如下图：<br>
<img src="/images/googlepay11.png" alt=""></li>
<li>如果是测试账号的订阅，最多可续订6次。<br>
如果是用测试账号来进行订阅的话，因为周期非常短，一个月循环5分钟就会到期，而一年的循环30分钟分钟就会到期。<br>
而且这种测试订阅最多可续订6次，也就是从刚开始订阅 {subId} 到 {subId}…5 这样子，最多6单过来之后，接下来 google 那边就会发过来取消循环的 webhook 了，然后就取消循环了。<br>
具体的文档：<a href="https://developer.android.com/google/play/billing/billing_testing#testing-renewals" target="_blank" rel="noopener">测试订阅续订</a><br>
感谢您的浏览，希望对您有所帮助！</li>
</ul>
<p><a href="https://kebingzao.com/2018/08/09/google-iap-gcp-webhook/" target="_blank" rel="noopener">Google iap webhook 接入(2) - 项目接入GCP webhook</a></p>
]]></content>
      <categories>
        <category>第三方</category>
      </categories>
      <tags>
        <tag>第三方</tag>
        <tag>Google Play</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMq</title>
    <url>/2019/12/08/RabbitMq/</url>
    <content><![CDATA[<h2 id="什么是消息队列">什么是消息队列</h2>
<p>“消息队列(Message Queue)”是在消息的传输过程中保存消息的容器。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。<br>
<img src="/images/rabbitmq.jpg" alt=""></p>
<a id="more"></a>
<h2 id="为什么使用消息队列">为什么使用消息队列</h2>
<p>主要有三个作用：</p>
<h3 id="解耦">* 解耦</h3>
<p>将消息写入消息队列，需要消息的系统自己从消息队列中订阅,从而系统A不需要做任何修改</p>
<h3 id="异步">* 异步</h3>
<p>将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</p>
<h3 id="削峰">* 削峰</h3>
<p>系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</p>
<h2 id="主流的MQ，如：kafka、rabbitmq、rocketmq、activemq">主流的MQ，如：kafka、rabbitmq、rocketmq、activemq</h2>
<p><img src="/images/messageque.jpg" alt=""></p>
<h2 id="消息队列的缺点">消息队列的缺点</h2>
<ol>
<li>系统可用性降低:<br>
本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低</li>
<li>系统复杂性增加:<br>
要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。但是，我们该用还是要用的。</li>
</ol>
<h2 id="RabbitMQ重要组件">RabbitMQ重要组件</h2>
<ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li>
<li>Channel（信道）：消息推送使用的通道。</li>
<li>Exchange（交换器）：用于接受、分配消息。</li>
<li>Queue（队列）：用于存储生产者的消息。RoutingKey（路由键）：用于把生成者的数据分配到交换器上。BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。<br>
消息推送到接收的过程：<br>
<img src="/images/producer-consumer.png" alt=""><br>
黄色的圈圈就是我们的消息推送服务，将消息推送到 中间方框里面也就是 rabbitMq的服务器，然后经过服务器里面的交换机、队列等各种关系（后面会详细讲）将数据处理入列后，最终右边的蓝色圈圈消费者获取对应监听的消息。<br>
常用的交换机有以下三种，因为消费者是从队列获取信息的，队列是绑定交换机的（一般），所以对应的消息推送/接收模式也会有以下几种：</li>
</ul>
<h4 id="Direct-Exchange">Direct Exchange</h4>
<p>直连型交换机，根据消息携带的路由键将消息投递给对应队列。<br>
大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key 。<br>
然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。</p>
<h4 id="Fanout-Exchange">Fanout Exchange</h4>
<p>扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。</p>
<h4 id="Topic-Exchange">Topic Exchange</h4>
<p>主题交换机，这个交换机其实跟直连交换机流程差不多，但是它的特点就是在它的路由键和绑定键之间是有规则的。<br>
简单地介绍下规则：<br>
‘*’(星号) 用来表示一个单词 (必须出现的)<br>
‘#’(井号) 用来表示任意数量（零个或多个）单词<br>
通配的绑定键是跟队列进行绑定的，举个小例子<br>
队列Q1 绑定键为 <em>.TT.</em>，队列Q2绑定键为  TT.#<br>
如果一条消息携带的路由键为 A.TT.B，那么队列Q1将会收到；<br>
<a href="http://xn--TT-uu2cyis92cyrg89d7xjqsh2qag53cpvv53d9v2ibzwa.AA.BB" target="_blank" rel="noopener">如果一条消息携带的路由键为TT.AA.BB</a>，那么队列Q2将会收到；</p>
<h2 id="消息交换器">消息交换器</h2>
<p>RabbitMQ消息交换器需要重点注意的是RabbitMQ支持临时和持久两种订阅类型。消费者可以调用RabbitMQ的API来选择他们想要的订阅类型。根据RabbitMQ的架构设计，我们也可以创建一种混合方法——订阅者以组队的方式然后在组内以竞争关系作为消费者去处理某个具体队列上的消息，这种由订阅者构成的组我们称为消费者组。按照这种方式，我们实现了发布/订阅模式，同时也能够很好的伸缩（scale-up）订阅者去处理收到的消息。</p>
<h2 id="RabbitMq的高可用性">RabbitMq的高可用性</h2>
<p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的<br>
RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>
<h3 id="单机模式">单机模式</h3>
<p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的 ，没人生产用单机模式。</p>
<h3 id="普通集群模式（无高可用性）">普通集群模式（无高可用性）</h3>
<p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。<br>
<img src="/images/ptjq.jpg" alt=""><br>
这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。<br>
而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。<br>
所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>
<h3 id="镜像集群模式（高可用性）">镜像集群模式（高可用性）</h3>
<p>RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。<br>
<img src="/images/rmgky.jpg" alt=""><br>
那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。<br>
这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</p>
<h2 id="Kafka-的高可用性">Kafka 的高可用性</h2>
<p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。<br>
实际上 RabbitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。<br>
Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。<br>
<img src="/images/kafka.jpg" alt=""><br>
Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。<br>
<img src="/images/kafkagky.jpg" alt=""></p>
<p>这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker 上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java高并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM详解</title>
    <url>/2019/12/08/JVM%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码解析</title>
    <url>/2019/11/23/currnthashmap/</url>
    <content><![CDATA[<h2 id="ConcurrentHashMap与HashMap等的区别">ConcurrentHashMap与HashMap等的区别</h2>
<p>1.HashMap<br>
我们知道HashMap是线程不安全的，在多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。<br>
2.HashTable<br>
HashTable和HashMap的实现原理几乎一样，差别无非是<br>
   HashTable不允许key和value为null<br>
   HashTable是线程安全的<br>
但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁。<br>
多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。<br>
3.ConcurrentHashMap<br>
主要就是为了应对hashmap在并发环境下不安全而诞生的，ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS等lock-free技术来减少锁竞争对于性能的影响。<br>
我们都知道Map一般都是数组+链表结构（JDK1.8该为数组+红黑树）。<br>
高并发编程系列：ConcurrentHashMap的实现原理(JDK1.7和JDK1.8)<br>
ConcurrentHashMap避免了对全局加锁改成了局部加锁操作，这样就极大地提高了并发环境下的操作速度，由于ConcurrentHashMap在JDK1.7和1.8中的实现非常不同，接下来我们谈谈JDK在1.7和1.8中的区别。</p>
<a id="more"></a>
<h2 id="JDK1-7的实现">JDK1.7的实现</h2>
<p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：<br>
<img src="/images/1.7conhashmap.png" alt=""><br>
Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样</p>
<h2 id="JDK1-8的实现">JDK1.8的实现</h2>
<p>JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本<br>
<img src="/images/1.8conhashmap.png" alt=""><br>
CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。<br>
CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p>
<h3 id="源码解析">源码解析</h3>
<h4 id="基本属性">基本属性</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node数组最大容量：2^30=1073741824  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认初始值，必须是2的幕数  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//数组可能最大值，需要与toArray（）相关方法关联  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//并发级别，遗留下来的，为兼容以前的版本  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//链表转红黑树的另一个阈值(条件)：Map的容量至少为64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//每次进行转移的最小值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//生成sizeCtl所使用的bit位数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 2^15-1，help resize扩容的最大线程数  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// forwarding nodes的hash值  </span></span><br><span class="line"><span class="comment">/** 首先哈希值不小于0，下面的几个常量相当于标识位 */</span></span><br><span class="line"><span class="comment">/** 用于转换节点的哈希值 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"><span class="comment">// 用于红黑树根节点的哈希码的标识位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"><span class="comment">// 容器中还有一个保留节点，此处也是有关的哈希码的标识位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="comment">// 可用cpu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">//存放node的数组,容器的数组（哈希表、散列表），在第一次插入元素时才初始化，大小总是2的次幂 </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/** 扩容时使用的临时过度的数组（仅使用于扩容） */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">//记录容器的容量大小，通过CAS更新</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个sizeCtl是volatile的，那么他是线程可见的，一个思考:它是所有修改都在CAS中进行，但是sizeCtl为什么不设计成LongAdder(jdk8出现的)类型呢？</span></span><br><span class="line"><span class="comment"> * 或者设计成AtomicLong(在高并发的情况下比LongAdder低效)，这样就能减少自己操作CAS了。</span></span><br><span class="line"><span class="comment"> * 默认为0，用来控制table的初始化和扩容操作，具体应用在后续会体现出来。</span></span><br><span class="line"><span class="comment"> * &lt;0 标识容器正在初始化或扩容</span></span><br><span class="line"><span class="comment"> * -1 代表table正在初始化</span></span><br><span class="line"><span class="comment"> * -N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment"> * 其余情况：</span></span><br><span class="line"><span class="comment"> *1、如果table未初始化，表示table需要初始化的大小。</span></span><br><span class="line"><span class="comment"> *2、如果table初始化完成，表示table的容量，默认是table大小的0.75 倍，居然用这个公式算0.75（n - (n &gt;&gt;&gt; 2)）。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  自旋锁 （锁定通过 CAS） 在调整大小和/或创建 CounterCells 时使用。 在CounterCell类更新value中会使用，功能类似显示锁和内置锁，性能更好</span></span><br><span class="line"><span class="comment"> *  在Striped64类也有应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"><span class="comment">/** 计数器池，非空时，大小为2的次幂 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>
<h4 id="ConcurrentHashMap-的构造函数">ConcurrentHashMap?的构造函数</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认无参构造函数</span></span><br><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//initialCapacity 初始化容量</span></span><br><span class="line"><span class="number">2</span>. <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 创建与给定map具有相同映射的新map</span></span><br><span class="line"><span class="number">3</span>. <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//initialCapacity 初始化容量;loadFactor 负载因子,当容量达到initialCapacity*loadFactor时，执行扩容</span></span><br><span class="line"><span class="number">4</span>. <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*initialCapacity 初始化容量;</span></span><br><span class="line"><span class="comment">* loadFactor 负载因子,当容量达到initialCapacity*loadFactor时，执行扩容</span></span><br><span class="line"><span class="comment">* concurrencyLevel 预估的并发更新线程数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">5</span>. <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads </span></span><br><span class="line">        <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;<span class="comment">//初始化sizeCtl</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *返回给定所需容量，table的大小总是2的幂次方</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作</p>
<h3 id="ConcurrentHashMap中各种数据节点">ConcurrentHashMap中各种数据节点</h3>
<p>jdk1.8 ConcurrentHashMap 中数据节点的种类比较多，比如 Node&lt;K, V&gt;、TreeNode&lt;K, V&gt;、TreeBin&lt;K, V&gt;、ReservationNode&lt;K,V&gt;。正式这种独具特色的设计，才拥有高性能的Map并发容器。</p>
<h4 id="Node">Node</h4>
<p>Node是ConcurrentHashMap存储结构的基本单元,保存key，value及key的hash值的数据结构，其中value和next都用volatile修饰，保证并发的可见性,继承于HashMap中的Entry，源代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现于 Map.Entry */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// // final 修饰的 哈希码、key，防止被重复赋值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// 具有可见性的 val 和 next</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="comment">// 当前节点指向的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法用于注入 node节点 的属性值(或引用)</span></span><br><span class="line"><span class="comment">     * 参数从左至右依次是：key的哈希码，key，value，指向的下一个节点next</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// getter &amp; toString 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">    <span class="comment">// 返回节点的哈希码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="comment">// 设置 value 的方法，可能会抛出不支持的操作异常,不允许更新value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于节点比较是否相等的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="comment">// 返回判断key、value是否相同的结果</span></span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚拟化地支持 map.get() 操作; 子类可以重写此方法.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node数据结构很简单，从上可知，就是一个链表，但是只允许对数据进行查找，不允许进行修改</p>
<h4 id="专用于红黑树的-TreeNode-K-V-节点">专用于红黑树的 TreeNode&lt;K, V&gt; 节点</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">// 指向上一个节点（一般是父节点），删除节点时会用到</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;</span><br><span class="line">    <span class="comment">// 红黑标识：true表示此节点为红色，false表示此节点为黑色</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">	<span class="comment">// 有参构造方法</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找并返回红黑树中是存在的节点，不存在返回null</span></span><br><span class="line"><span class="comment">     * 在上篇关于jdk1.8HashMap源码分析的文章中，分析过类似的（写）操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// 循环遍历平衡树</span></span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="comment">// ph：当前节点的哈希码，</span></span><br><span class="line">                <span class="comment">// dir：搜索的方向，左或右：-1表示左，1表示右，</span></span><br><span class="line">                <span class="comment">// pk：当前节点的key</span></span><br><span class="line">                <span class="comment">// q：当前节点</span></span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                <span class="comment">// pl：当前节点p的左子节点；pr：当前节点p的右子节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">// 当前节点的哈希值大于指定的哈希值，指向左子节点</span></span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    <span class="comment">// 当前节点的哈希值小于指定的哈希值，指向右子节点</span></span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="comment">// 如果当前节点的key与指定的k相同，那么就直接返回此节点</span></span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 如果左子节点为空，就向右子节点查找</span></span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 如果右子节点为空，就向左子节点查找</span></span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="comment">// 判断 k 的类是否实现了比较器</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          <span class="comment">// 判断 k 的类是否实现了比较器</span></span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         <span class="comment">// 这里实际是 pk == null || pk.getClass() != kc ? 0 :</span></span><br><span class="line">                         <span class="comment">// ((Comparable)pk).compareTo(pk)</span></span><br><span class="line">                         <span class="comment">// 下面是解读这个三目运算：</span></span><br><span class="line">                         <span class="comment">// pk == null 表示判断当前节点是否为null</span></span><br><span class="line">                         <span class="comment">// pk.getClass() != kc 表示当前节点对象的类和key的对象的类是否不同</span></span><br><span class="line">                         <span class="comment">// ((Comparable)k).compareTo(pk)表示将指定的key与当前节点的key比较</span></span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// dir小于0表示向左子节点搜索</span></span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="comment">// 循环查找</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="computeIfAbsent-和-compute-方法使用的位置-保留节点">computeIfAbsent 和 compute 方法使用的位置 保留节点</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    ReservationNode() &#123;</span><br><span class="line">        <span class="keyword">super</span>(RESERVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="持有红黑树根节点的容器">持有红黑树根节点的容器</h4>
<p>TreeBin 是保证 ConcurrentHashMap 线程安全的重要数据结构，它自身维护着读/写锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 红黑树的根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="comment">// // 链表的头节点（桶顶的节点）</span></span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 最近一个设置 waiter 标识位的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="comment">// 锁状态标识位</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// 持有写锁时的状态位</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// 正在等待写锁的状态位</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// 设置读锁时的增量值</span></span><br><span class="line">    </span><br><span class="line">    ...其他方法跟 TreeNode 中的方法很相似</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConcurrentHashMap添加元素操作">ConcurrentHashMap添加元素操作</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不允许key、value为null</span></span><br><span class="line">    <span class="comment">// 将null值判断提前，符合异常处理的规则（这里也是较上一版做了优化）</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 计算key的哈希码</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// binCount 用来记录链表中节点数量，进而判断是否达到转为红黑树的阈值</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历table数组</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">         <span class="comment">// 要插入元素所在位置的节点</span></span><br><span class="line">        Node&lt;K,V&gt; f;</span><br><span class="line">        <span class="comment">// n 表示数组长度；i 表示索引；fh 表示要插入元素所在位置的节点的哈希码</span></span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果数组为null或者数组的大小为0，那么进行初始化数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过指定key的哈希码找到对应的节点，</span></span><br><span class="line">            <span class="comment">// 在节点为null的情况下，通过CAS自旋方式将这个元素放入其中</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="comment">// 如果通过CAS自旋成功添加元素，就直接跳出循环</span></span><br><span class="line">                <span class="comment">// 否则就进入下一个循环</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">        <span class="comment">// 标识着要迁移数据</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 通过上面过滤的条件，在应该能猜到下面不是关于链表就是关于红黑树</span></span><br><span class="line">        <span class="comment">// 因为哈希槽的位置不为null</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//旧值</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//只给单个节点加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//再次判断结点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 判断节点f的哈希码是否不小于0</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 从桶顶（哈希槽）开始遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 判断key是否相同</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">// 如果相同的话，就准备获取value</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// onlyIfAbsent为true标识可以覆盖value，false标识不允许覆盖 </span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                <span class="comment">// 如果允许覆盖value，就覆盖value</span></span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 记录下一个节点的上一个节点（目前以为着是当前节点e）</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 如果当前节点的下一个节点为null，就把元素添加到链表的尾部</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="comment">// 添加完成后就直接跳出循环</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 将元素添加到红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="comment">// 是否可以覆盖已有的value</span></span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断在链表不为空的情况下，是否达到转为红黑树的阈值</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                 <span class="comment">// 如果链表元素达到转为红黑树的阈值，就转为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加计数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个或多个线程正在对ConcurrentHashMap进行扩容操作，当前线程也要进入扩容的操作中。这个扩容的操作之所以能被检测到，是因为transfer方法中在空结点上插入forward节点，如果检测到需要插入的位置被forward节点占有，就帮助进行扩容；<br>
如果检测到要插入的节点是非空且不是forward节点，就对这个节点加锁，这样就保证了线程安全。尽管这个有一些影响效率，但是还是会比HashTable的synchronized要好得多。<br>
putVal(K key, V value, boolean onlyIfAbsent)方法干的工作如下：</p>
<ol>
<li>检查key/value是否为空，如果为空，则抛异常，否则进行2</li>
<li>进入for死循环，进行3</li>
<li>检查table是否初始化了，如果没有，则调用initTable()进行初始化然后进行 2，否则进行4</li>
<li>根据key的hash值计算出其应该在table中储存的位置i，取出table[i]的节点用f表示。<br>
根据f的不同有如下三种情况：<br>
(1) 如果table[i]==null(即该位置的节点为空，没有发生碰撞)，<br>
则利用CAS操作直接存储在该位置，如果CAS操作成功则退出死循环。<br>
(2) 如果table[i]!=null(即该位置已经有其它节点，发生碰撞)，碰撞处理也有两种情况<br>
(2.1)检查table[i]的节点的hash是否等于MOVED，如果等于，则检测到正在扩容，则帮助其扩容<br>
(2.2)说明table[i]的节点的hash值不等于MOVED，如果table[i]为链表节点，则将此节点插入链表中即可<br>
(3) 如果table[i]为树节点，则将此节点插入树中即可。插入成功后，进行 5</li>
<li>如果table[i]的节点是链表节点，则检查table的第i个位置的链表是否需要转化为数，如果需要则调用treeifyBin函数进行转化</li>
</ol>
<p>1、第一步根据给定的key的hash值找到其在table中的位置index。<br>
2、找到位置index后，存储进行就好了。</p>
<p>只是这里的存储有三种情况罢了，第一种：table[index]中没有任何其他元素，即此元素没有发生碰撞，这种情况直接CAS存储就好了哈。第二种，table[i]存储的是一个链表，如果链表不存在key则直接加入到链表尾部即可，如果存在key则更新其对应的value。第三种，table[i]存储的是一个树，则按照树添加节点的方法添加就好。第二种和第三种需要对节点进行加锁。</p>
<h2 id="相关问题">相关问题</h2>
<h3 id="并发环境下为什么使用ConcurrentHashMap">并发环境下为什么使用ConcurrentHashMap?</h3>
<ol>
<li>HashMap线程不安全</li>
<li>HashTable虽然是线程安全的，但是效率低下，当一个线程访问HashTable的同步方法时，其他线程如果也访问HashTable的同步方法，那么会进入阻塞或者轮训状态。</li>
<li>在jdk1.6中ConcurrentHashMap使用锁分段技术提高并发访问效率。首先将数据分成一段一段地存储，然后给每一段数据配一个锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问。然而在jdk1.8中的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。</li>
</ol>
<h2 id="总结">总结</h2>
<p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。<br>
1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。<br>
2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。<br>
3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。<br>
4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java源码解析</category>
      </categories>
      <tags>
        <tag>Java源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/2019/11/18/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="相关概念">相关概念</h2>
<h3 id="数组">数组</h3>
<p>数组具有遍历快，增删慢的特点。数组在堆中是一块连续的存储空间，遍历时数组的首地址是知道的（首地址=首地址+元素字节数 * 下标），所以遍历快（数组遍历的时间复杂度为O(1) ）；增删慢是因为，当在中间插入或删除元素时，会造成该元素后面所有元素地址的改变，所以增删慢（增删的时间复杂度为O(n) ）。</p>
<h3 id="链表">链表</h3>
<p>链表具有增删快，遍历慢的特点。链表中各元素的内存空间是不连续的，一个节点至少包含节点数据与后继节点的引用，所以在插入删除时，只需修改该位置的前驱节点与后继节点即可，链表在插入删除时的时间复杂度为O(1)。但是在遍历时，get(n)元素时，需要从第一个开始，依次拿到后面元素的地址，进行遍历，直到遍历到第n个元素（时间复杂度为O(n) ），所以效率极低。</p>
<h3 id="HashMap">HashMap</h3>
<p>Hash表是一个数组+链表的结构，这种结构能够保证在遍历与增删的过程中，如果不产生hash碰撞，仅需一次定位就可完成，时间复杂度能保证在O(1)。  在jdk1.7中，只是单纯的数组+链表的结构，但是如果散列表中的hash碰撞过多时，会造成效率的降低，所以在JKD1.8中对这种情况进行了控制，当一个hash值上的链表长度大于8时，该节点上的数据就不再以链表进行存储，而是转成了一个红黑树。</p>
<a id="more"></a>
<h3 id="hash碰撞：">hash碰撞：</h3>
<p>hash是指，两个元素通过hash函数计算出的值是一样的，是同一个存储地址。当后面的元素要插入到这个地址时，发现已经被占用了，这时候就产生了hash冲突</p>
<h3 id="hash冲突的解决方法：">hash冲突的解决方法：</h3>
<p>开放定址法(查询产生冲突的地址的下一个地址是否被占用，直到寻找到空的地址)，再散列法，链地址法等。hashmap采用的就是链地址法，jdk1.7中，当冲突时，在冲突的地址上生成一个链表，将冲突的元素的key，通过equals进行比较，相同即覆盖，不同则添加到链表上，此时如果链表过长，效率就会大大降低，查找和添加操作的时间复杂度都为O(n)；但是在jdk1.8中如果链表长度大于8，链表就会转化为红黑树，时间复杂度也降为了O(logn)，性能得到了很大的优化。</p>
<h3 id="HashMap的继承图（盗图）">HashMap的继承图（盗图）</h3>
<p><img src="/images/hashmapentends.jpg" alt=""><br>
HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null ，允许多条记录的值为 null 。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<h3 id="HashMap存储结构">HashMap存储结构</h3>
<p><img src="/images/hashmap.jpg" alt=""></p>
<h2 id="源码分析">源码分析</h2>
<h3 id="常量定义">常量定义</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建 HashMap 时未指定初始容量情况下的默认容量为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//HashMap最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//HashMap 默认的负载因子（也叫填充比）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;   <span class="comment">//表示当map集合中存储的数据达到当前数组大小的75%则需要进行扩容</span></span><br><span class="line"><span class="comment">//用来确定何时将解决 hash 冲突的链表转变为红黑树,如果主干数组上的链表的长度大于8，链表转化为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//用来确定何时将解决 hash 冲突的红黑树转变为链表,hash表扩容后，如果发现某一个红黑树的长度小于6，则会重新退化为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//当hashmap容量大于64时，链表才能转成红黑树,若是由于数组容量太小（小于64）导致的 hash 冲突太多，则不进行链表转变为红黑树操作，转为利用　resize() 函数对　hashMap 扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//保存Node&lt;K,V&gt;节点的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//由　hashMap 中 Node&lt;K,V&gt;　节点构成的 set</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">//Map中当前存储的元素数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//阈值，用于判断是否需要扩容（threshold = 容量*负载因子）</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//HashMap加载因子实际的大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//HashMap发生结构性变化的次数（注意　value 的覆盖不属于结构性变化）</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法">构造方法</h3>
<p>HashMap的构造方法有4种，主要涉及到的参数有，指定初始容量，指定填充比和用来初始化的Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数1 指定初始容量和负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定的初始容量非负</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Illegal initial capacity:  +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//如果指定的初始容量大于最大容量,置为最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//填充比为正</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Illegal load factor:  +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">/* tableSizeFor(initialCapacity)　方法返回的值是最接近 initialCapacity 的2的幂，若指定初始容量为9，则实际 hashMap 容量为16*/</span></span><br><span class="line">    　<span class="comment">//注意此种方法创建的 hashMap 初始容量的值存在　threshold 中</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//新的扩容临界值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tableSizeFor(initialCapacity)　方法返回的值是最接近 initialCapacity 的2的幂</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">// &gt;&gt;&gt; 代表无符号右移</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数2 指定初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数3 无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数4 用m的元素初始化散列映射 指定集合 转化为iHashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;!--? extends K, ? extends V--&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组里面每个地方都存了Key-Value这样的实例，在Java7叫Entry在Java8中叫Node。数组和链表组合构成的数据结构大概如下-偷图-：">数组里面每个地方都存了Key-Value这样的实例，在Java7叫Entry在Java8中叫Node。数组和链表组合构成的数据结构大概如下(偷图)：</h3>
<p><img src="/images/arraylist.jpg" alt=""><br>
因为他本身所有的位置都为null，在put插入的时候会根据key的hash去计算一个index值。<br>
就比如我put（”帅丙“，520），我插入了为”帅丙“的元素，这个时候我们会通过哈希函数计算出插入的位置，计算出来index是2那结果如下(偷图)。<br>
hash（“帅丙”）= 2<br>
<img src="/images/shuaibing.jpg" alt=""><br>
我们都知道数组长度是有限的，在有限的长度里面我们使用哈希，哈希本身就存在概率性，就是”帅丙“和”丙帅“我们都去hash有一定的概率会一样，就像上面的情况我再次哈希”丙帅“极端情况也会hash到一个值上，那就形成了链表（偷图）。<br>
<img src="/images/bingshuai.jpg" alt=""><br>
每一个节点都会保存自身的hash、key、value、以及下个节点，我看看Node的源码。<br>
<img src="/images/node.jpg" alt=""><br>
下图是一位大神级别画的图，自己就不再造轮子了。客官请看<br>
<img src="/images/putval.jpg" alt=""></p>
<h3 id="HashMap的put-，存值过程">HashMap的put()，存值过程</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;<span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"> <span class="comment">/*key 的 hash　值的计算是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销*/</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*把Map&lt;? extends K, ? extends V&gt; m 中的元素插入到　hashMap 中,若 evict 为 false,代表是在创建 hashMap 时调用了这个函数，例如利用上述构造函数３创建 hashMap;若 evict　为true,代表是在创建　hashMap 后才调用这个函数，例如上述的　putAll 函数。*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*如果是在创建 hashMap 时调用的这个函数则 table 一定为空*/</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">        <span class="comment">//根据待插入的map 的 size 计算要创建的　hashMap 的容量。</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//把要创建的　hashMap 的容量存在　threshold　中</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断待插入的map 的 size,若size 大于threshold，则先进行resize()</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            <span class="comment">//实际也是调用　putVal　函数进行元素的插入</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 判断数组是否为空，长度是否为0，是则进行扩容数组初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 通过hash算法找到数组下标得到数组元素，如果table的在（n-1）&amp;hash的值为空则新建（注意确定插入位置所用的计算方法为　(n - 1) &amp; hash,由于　n 一定是２的幂次，这个操作相当于hash % n ）</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">////说明待插入位置存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//  比较原来元素与待插入元素的　hash 值和　key 值，hash相等同时key相等，则直接覆盖（检查第一个Node，p是不是要找的值）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 该数组元素在链表长度&gt;8后形成红黑树结构的对象,p为树结构已存在的对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该数组元素hash相等，key不等，同时链表长度&lt;8.进行遍历寻找元素，有就覆盖无则新建</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 新建链表中数据元素，尾插法</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度&gt;=8 结构转为 红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果遍历过程中链表中的元素与新添加的元素完全相同，key存在，直接覆盖，则跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;<span class="comment">//将p中的next赋值给p,即将链表中的下一个node赋值给p，</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 新值覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key  //这个判断中代码作用为：如果添加的元素产生了hash冲突，那么调用put方法时，会将他在链表中他的上一个元素的值返回</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  put方法中调用的putTreeVal函数</span></span><br><span class="line"><span class="comment">/*读懂这个函数要注意理解 hash 冲突发生的几种情况</span></span><br><span class="line"><span class="comment"> 1、两节点　key 值相同（hash值一定相同），导致冲突</span></span><br><span class="line"><span class="comment"> 2、两节点　key 值不同，由于 hash 函数的局限性导致hash 值相同，冲突</span></span><br><span class="line"><span class="comment"> 3、两节点　key 值不同，hash 值不同，但 hash 值对数组长度取模后相同，冲突</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//从根节点开始查找合适的插入位置（与二叉搜索树查找过程相同）</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>; <span class="comment">//dir小于0，接下来查找当前节点左孩子</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>; <span class="comment">//　dir大于0，接下来查找当前节点右孩子</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">        <span class="comment">//进入这个else if 代表　hash 值相同，key　相同</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">                <span class="comment">/*要进入下面这个else if,代表有以下几个含义:</span></span><br><span class="line"><span class="comment">            1、当前节点与待插入节点　key　不同,　hash 值相同</span></span><br><span class="line"><span class="comment">　　　　　　 2、k是不可比较的，即k并未实现　comparable&lt;K&gt;　接口</span></span><br><span class="line"><span class="comment">　　　　　　　　　　　　　　（若 k 实现了comparable&lt;K&gt;　接口，comparableClassFor（k）返回的是k的　class,而不是　null）</span></span><br><span class="line"><span class="comment">            　　或者　compareComparables(kc, k, pk)　返回值为 0</span></span><br><span class="line"><span class="comment">　　　　　　　　　　　　　　(pk 为空　或者　按照 k.compareTo(pk) 返回值为0，</span></span><br><span class="line"><span class="comment">　　　　　　　　　　　　　　返回值为0可能是由于　ｋ的compareTo 方法实现不当引起的，compareTo 判定相等，而上个 else if　中　equals 判定不等)*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//在以当前节点为根的整个树上搜索是否存在待插入节点（只会搜索一次）</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                        <span class="comment">//若树中存在待插入节点，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 既然ｋ是不可比较的，那我自己指定一个比较方式</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//找到了待插入的位置，xp 为待插入节点的父节点</span></span><br><span class="line">　　　　　　　　　　<span class="comment">//注意TreeNode节点中既存在树状关系，也存在链式关系，并且是双端链表</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                <span class="comment">//插入节点后进行二叉树的平衡操作</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="comment">//System.identityHashCode()实际是利用对象 a,b 的内存地址进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">            compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//put方法的treeifyBin()函数，链表转化为红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果表为空或者表的长度小于树化的容量，resize()扩容而不是树化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//hd是转换为树节点后桶中的头节点   tl记录上一个遍历的节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//将hash位置处的数组中的每个节点包装成树节点，p记录当前遍历的节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        <span class="comment">//循环将桶中每个节点替换为树节点，最终结果就是链表转换为双向链表，prev指向前一个节点，next指向后一个节点</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//将双向链表转化为红黑树</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本过程如下:</p>
<ol>
<li>检查数组是否为空，执行resize()扩充；在实例化HashMap时，并不会进行初始化数组</li>
<li>通过hash值计算数组索引，获取该索引位的首节点。</li>
<li>如果首节点为null（没发生碰撞），则创建新的数组元素，直接添加节点到该索引位(bucket)。</li>
<li>如果首节点不为null（发生碰撞），那么有3种情况<br>
① key和首节点的key相同，覆盖old value（保证key的唯一性）；否则执行②或③<br>
② 如果首节点是红黑树节点（TreeNode），将键值对添加到红黑树。<br>
③ 如果首节点是链表，进行遍历寻找元素，有就覆盖无则新建，将键值对添加到链表。添加之后会判断链表长度是否到达TREEIFY_THRESHOLD - 1这个阈值，“尝试”将链表转换成红黑树。</li>
<li>最后判断当前元素个数是否大于threshold，扩充数组。</li>
</ol>
<h3 id="HashMap的get-取值过程">HashMap的get(),取值过程</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//实际上是根据输入节点的 hash 值和 key 值利用getNode 方法进行查找</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">//Entry对象数组  </span></span><br><span class="line">    Node&lt;K,V&gt; first, e; <span class="comment">//在tab数组中经过散列的第一个位置  </span></span><br><span class="line">    <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">/*找到插入的第一个Node，方法是hash值和n-1相与，tab[(n - 1) &amp; hash]*/</span>  </span><br><span class="line">    <span class="comment">//也就是说在一条链上的hash值相同的  </span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 永远检查第一个node是不是要找的Node</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//判断条件是hash值要相同，key值要相同  </span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">/*检查first后面的node*/</span>  </span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 树查找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">/*遍历后面的链表，找到key值和hash值都相同的Node*/</span>  </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  <span class="comment">// 遍历链表</span></span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get方法中调用到的getTreeNode函数">get方法中调用到的getTreeNode函数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">//首先进行hash 值的比较，若不同令当前节点变为它的左孩子或者右孩子</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//hash 值相同，进行 key值的比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//执行到这儿，意味着hash 值相同，key 值不同</span></span><br><span class="line">        <span class="comment">//若k 是可比较的并且k.compareTo(pk) 返回结果不为０可进入下面elseif  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                    (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="comment">/*若 k 是不可比较的　或者　k.compareTo(pk) 返回结果为０则在整棵树中进行查找，先找右子树，右子树没有再找左子树*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在HashMap 1.8中，无论是存元素还是取元素，都是优先判断bucket上第一个元素是否匹配，而在1.7中则是直接遍历查找。<br>
基本过程如下:</p>
<ol>
<li>根据key计算hash;</li>
<li>检查数组是否为空，为空返回null;</li>
<li>根据hash计算bucket位置，如果bucket第一个元素是目标元素，直接返回。否则执行4;</li>
<li>如果bucket上元素大于1并且是树结构，则执行树查找。否则执行5;</li>
<li>如果是链表结构，则遍历寻找目标</li>
</ol>
<h3 id="HashMap的remove-删除操作">HashMap的remove(),删除操作</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">     <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                table[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作，先计算指定key的hash值，然后计算出table中的存储位置，判断当前位置是否Entry实体存在，如果没有直接返回，若当前位置有Entry实体存在，则开始遍历列表。定义了三个Entry引用，分别为pre, e ,next。 在循环遍历的过程中，首先判断pre 和 e 是否相等，若相等表明，table的当前位置只有一个元素，直接将table[i] = next = null 。若形成了pre -&gt; e -&gt; next 的连接关系，判断e的key是否和指定的key 相等，若相等则让pre -&gt; next ,e 失去引用。</p>
<h3 id="HashMap的resize-扩容机制">HashMap的resize(),扩容机制</h3>
<p>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比<em>Node.length）重新调整HashMap大小 变为原来2倍大小,扩容很耗时<br>
HashMap扩容可以分为三种情况：<br>
第一种：使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 16</em>0.75 = 12。<br>
第二种：指定初始容量的构造方法初始化HashMap。那么从下面源码可以看到初始容量会等于threshold，接着threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。<br>
第三种：HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍。<br>
这边也可以引申到一个问题HashMap是先插入还是先扩容：HashMap初始化后首次插入数据时，先发生resize扩容再插入数据，之后每当插入的数据个数达到threshold时就会发生resize，此时是先插入数据再resize。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">//原表,首次初始化后table为Null</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//原表大小,默认构造器的情况下为0</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">//（threshold）阈值， 为 oldCap × load_factor</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//记录新表的大小和阈值</span></span><br><span class="line">    <span class="comment">//旧表容量大于0，表示被初始化过，需要执行的是扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//table扩容过</span></span><br><span class="line">        <span class="comment">//如果旧表容量大于容量最大值，那么阈值为Interger的最大值，即提升阈值，不再进行扩容，返回旧表</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，扩容为原先容量的1倍，阈值也扩容为原来的一倍 即现在新表table的容量乘以2，threshold的值也乘以2 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//旧表容量为0，阈值大于0，则用阈值大小作为容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    <span class="comment">//使用带有初始容量的构造器时，table容量为初始化得到的threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//否则，表的容量为默认初始容量16，阈值为默认初始容量16*加载因子0.75</span></span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//默认构造器下进行扩容             // zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新表阈值为0，则利用新容量*加载因子计算</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//使用带有初始容量的构造器在此处进行扩容</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor; <span class="comment">//新表长度乘以加载因子  </span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新的阈值赋给HashMap的阈值成员变量</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">/*下面开始构造新表，初始化表中的数据*/</span>  </span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;<span class="comment">//把新表赋值给table  </span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原表不是空要把原表中数据移动到新表中</span></span><br><span class="line">    <span class="comment">/*遍历原来的旧表*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">//// 当前index没有发生hash冲突，直接对2取模，即移位运算hash &amp;（2^n -1）</span></span><br><span class="line">                        <span class="comment">// 扩容都是按照2的幂次方扩容，因此newCap = 2^n</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 当前index对应的节点为红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//桶中存放的是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order 保证顺序</span></span><br><span class="line">                <span class="comment">// 把当前index对应的链表分成两个链表，减少扩容的迁移量，根据变化的最高位的不同，也就是0或者1，将链表拆分开</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;<span class="comment">//记录下一个结点</span></span><br><span class="line">                        <span class="comment">//最高位为0，则将节点加入loTail.next</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//扩容后不需要移动的链表</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//最高位为1，则将节点加入hiTail.next</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;<span class="comment">// 扩容后需要移动的链表</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">//在新数组的位置与原数组的位置相同,新数组的桶直接指向LoHead</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;<span class="comment">//在新数组的位置是原数组的位置+旧数组长度,新数组的桶直接指向hiHead</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 扩容长度为当前index位置+旧的容量</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相关问题">相关问题</h2>
<h3 id="加载因子（默认0-75）：为什么需要使用加载因子，为什么需要扩容呢？">加载因子（默认0.75）：为什么需要使用加载因子，为什么需要扩容呢？</h3>
<p>因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率</p>
<h3 id="JDK1-8使用红黑树的改进">JDK1.8使用红黑树的改进</h3>
<p>在Java jdk8中对HashMap的源码进行了优化，在jdk7中，HashMap处理“碰撞”的时候，都是采用链表来存储，当碰撞的结点很多时，查询时间是O（n）。<br>
在jdk8中，HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞结点较少时，采用链表存储，当较大时（&gt;8个），采用红黑树（特点是查询时间是O（logn））存储（有一个阀值控制，大于阀值(8个)，将链表存储转换成红黑树存储）<br>
<img src="/images/redblacktree.jpg" alt=""><br>
如果某HashMap中的记录过大的话（当前是TREEIFY_THRESHOLD = 8），HashMap会动态的使用一个专门的treemap实现来替换掉它。这样做的结果会更好，是O(logn)，而不是糟糕的O(n)。<br>
它是如何工作的？<br>
前面产生冲突的那些key对应的记录只是简单的追加到一个链表后面，这些记录只能通过遍历来进行查找。但是超过这个阈值后HashMap开始将列表升级成一个二叉树，使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个hashmap的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。这对HashMap的key来说并不是必须的，不过如果实现了当然最好。如果没有实现这个接口，在出现严重的哈希碰撞的时候，你就并别指望能获得性能提升了。</p>
<h3 id="Entry节点在插入链表的时候，是如何插入的？">Entry节点在插入链表的时候，是如何插入的？</h3>
<p>java8之前是头插法，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样。<br>
但是，在java8之后，都是所用尾部插入了。<br>
为啥改为尾部插入呢？<br>
解决1.7中多线程循环链表的bug<br>
先举个例子吧，我们现在往一个容量大小为2的put两个值，负载因子是0.75是不是我们在put第二个的时候就会进行resize？<br>
2*0.75 = 1 所以插入第二个就要resize了<br>
现在我们要在容量为2的容器里面用不同线程插入A，B，C，假如我们在resize之前打个短点，那意味着数据都插入了但是还没resize那扩容前可能是这样的。<br>
我们可以看到链表的指向A-&gt;B-&gt;C<br>
Tip：A的下一个指针是指向B的<br>
<img src="/images/ab.jpg" alt=""><br>
因为resize的赋值方式，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。<br>
就可能出现下面的情况，大家发现问题没有？<br>
B的下一个指针指向了A<br>
<img src="/images/ba.jpg" alt=""><br>
一旦几个线程都调整完成，就可能出现环形链表<br>
<img src="/images/circlelist.jpg" alt=""><br>
如果这个时候去取值，悲剧就出现了——Infinite Loop(无限循环)。<br>
因为java8之后链表有红黑树的部分，大家可以看到代码已经多了很多if else的逻辑判断了，红黑树的引入巧妙的将原本O(n)的时间复杂度降低到了O(logn)。<br>
使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。<br>
就是说原本是A-&gt;B，在扩容后那个链表还是A-&gt;B<br>
<img src="/images/abb.jpg" alt=""><br>
Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。<br>
Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</p>
<h3 id="那是不是意味着Java8就可以把HashMap用在多线程中呢？">那是不是意味着Java8就可以把HashMap用在多线程中呢？</h3>
<p>即使不会出现死循环，但是通过源码看到put/get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。</p>
<h3 id="HashMap的默认初始化长度是多少？原因？">HashMap的默认初始化长度是多少？原因？</h3>
<p>初始化大小是16<br>
我们在创建HashMap的时候，阿里巴巴规范插件会提醒我们最好赋初值，而且最好是2的幂。<br>
这样是为了位运算的方便，位与运算比算数计算的效率高了很多，之所以选择16，是为了服务将Key映射到index的算法。</p>
<h3 id="那为啥用16不用别的呢？">那为啥用16不用别的呢？</h3>
<p>因为在使用不是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。<br>
只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。<br>
这是为了实现均匀分布。</p>
<h3 id="为啥我们重写equals方法的时候需要重写hashCode方法呢？">为啥我们重写equals方法的时候需要重写hashCode方法呢？</h3>
<p>因为在java中，所有的对象都是继承于Object类。Object类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的。<br>
在未重写equals方法我们是继承了object的equals方法，那里的 equals是比较两个对象的内存地址，显然我们new了2个对象内存地址肯定不一样<br>
对于值对象，==比较的是两个对象的值<br>
对于引用对象，比较的是两个对象的地址<br>
大家是否还记得我说的HashMap是通过key的hashCode去寻找index的，那index一样就形成链表了，也就是说”帅丙“和”丙帅“的index都可能是2，在一个链表上的。<br>
我们去get的时候，他就是根据key去hash然后计算出index，找到了2，那我怎么找到具体的”帅丙“还是”丙帅“呢？<br>
equals！是的，所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，以保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。<br>
不然一个链表的对象，你哪里知道你要找的是哪个，到时候发现hashCode都一样</p>
<h3 id="怎么处理HashMap在线程安全的场景么？">怎么处理HashMap在线程安全的场景么？</h3>
<p>我们一般都会使用HashTable或者ConcurrentHashMap，但是因为前者的并发度的原因基本上没啥使用场景了，所以存在线程不安全的场景我们都使用的是ConcurrentHashMap。<br>
HashTable我看过他的源码，很简单粗暴，直接在方法上锁，并发度很低，最多同时允许一个线程访问，ConcurrentHashMap就好很多了，1.7和1.8有较大的不同，不过并发度都比前者好太多了。</p>
<h3 id="什么时候resize">什么时候resize?</h3>
<p>有两个因素：</p>
<ul>
<li>Capacity：HashMap当前长度。</li>
<li>LoadFactor：负载因子，默认值0.75f。<br>
举个例子：就比如当前的容量大小为100，当你存进第76个的时候，判断发现需要进行resize了，那就进行扩容，但是HashMap的扩容也不是简单的扩大点容量这么简单的。</li>
</ul>
<h3 id="扩容？它是怎么扩容的呢？">扩容？它是怎么扩容的呢？</h3>
<p>分为两步</p>
<ul>
<li>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</li>
<li>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li>
</ul>
<h3 id="为什么要重新Hash呢，直接复制过去不香么？">为什么要重新Hash呢，直接复制过去不香么？</h3>
<p>是因为长度扩大以后，Hash的规则也随之改变。<br>
Hash的公式—&gt; index = HashCode（Key） &amp; （Length - 1）<br>
原来长度（Length）是8你位运算出来的值是2 ，新的长度是16你位运算出来的值明显不一样了。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java源码解析</category>
      </categories>
      <tags>
        <tag>Java源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker之部署脚本.deploysh</title>
    <url>/2019/11/14/docker-deploysh/</url>
    <content><![CDATA[<h2 id="说明">说明</h2>
<p>假如我要使用docker构建容器部署springboot项目，步骤：</p>
<ol>
<li>把jar包上传到服务器上</li>
<li>创建DockFile文件</li>
<li>编译镜像<br>
<code>docker build -t test.</code></li>
<li>启动容器<br>
<code>docker run --name test -p 8080:8080 -d test</code></li>
</ol>
<a id="more"></a>
<p>–name为指定容器的名称；<br>
-p指定容器暴露的端口<br>
-d以后台进程运行<br>
每次更新jar包时，只需执行<code>docker stop test</code>、<code>docker start test</code>就可以了，就将新的应用进行了发布。<br>
上面步骤虽然解决了更新jar包的问题，但是又出现了一个问题就是在Dockerfile中将使用的jar包名称写死了，这样每次更新jar包必须是同样的jar包，这样当应用从1.1版本更新1.2版本时就很痛苦，需要将本是1.2版本的jar包改名为1.1，这样会导致后续jar包的错乱。为了解决这个问题，我们就可以使用.deploysh脚本啦，模版如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">CURRENT=`pwd`</span><br><span class="line">cd $(dirname $0)</span><br><span class="line"></span><br><span class="line">if [ $# != 3 ] ; then</span><br><span class="line">   echo Error ! $0 app.jar config_dir name</span><br><span class="line">   echo PORT in yml/properties file to config AND SPRING_PROFILES_ACTIVE=online</span><br><span class="line">   exit 1;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">DOCKER_NAME=$3</span><br><span class="line">TAG_NAME=`date +%s`</span><br><span class="line"></span><br><span class="line">set -e -x</span><br><span class="line"></span><br><span class="line">TMP="/tmp/docker-template/"</span><br><span class="line">rm -rf $TMP</span><br><span class="line">mkdir $TMP</span><br><span class="line"></span><br><span class="line">cp $CURRENT/$1 "$TMP/app.jar"</span><br><span class="line">cp -r $CURRENT/$2 "$TMP/config/"</span><br><span class="line">cp Dockerfile "$TMP/Dockerfile"</span><br><span class="line"></span><br><span class="line">cd $TMP</span><br><span class="line"></span><br><span class="line">sudo /usr/bin/docker build . -t $DOCKER_NAME:$TAG_NAME --build-arg JAR=app.jar</span><br><span class="line">sudo /usr/bin/docker tag $DOCKER_NAME:$TAG_NAME $DOCKER_NAME:latest</span><br><span class="line"></span><br><span class="line">sudo /usr/bin/docker ps|grep $DOCKER_NAME &amp;&amp; sudo /usr/bin/docker stop $DOCKER_NAME</span><br><span class="line">sudo /usr/bin/docker ps -a|grep $DOCKER_NAME &amp;&amp; sudo /usr/bin/docker rm $DOCKER_NAME</span><br><span class="line">sudo /usr/bin/docker run -d --net host --restart always --name $DOCKER_NAME -v /var/log/:/var/log/ $DOCKER_NAME:$TAG_NAME</span><br><span class="line"></span><br><span class="line">rm -rf $TMP</span><br></pre></td></tr></table></figure>
<p>通过此脚本，每次更新应用时我们就可以<code>.deploysh test.jar conf/ test</code>就可以啦，是不是方便多啦<sup>_</sup>！<br>
conf是和jar包基于同级目录的配置目录，conf目录下放springboot项目的配置文件，eg:applicaion.yml,运行容器时就会加载此配置文件。</p>
<h2 id="usage">usage</h2>
<p>demo:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./deploy.sh ready-to-deploy.jar ./config-directory/ docker-cotainer-name</span><br></pre></td></tr></table></figure>
<p>SPRING_PROFILES_ACTIVE is “online”, Server port is config IN application-online.yml / application-online.properties with default.</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker之Dockfile</title>
    <url>/2019/11/14/docker-dockerfile/</url>
    <content><![CDATA[<h2 id="Dockerfile是什么？">Dockerfile是什么？</h2>
<p>Docker可以通过阅读Dockerfile中的指令来自动构建映像。 Dockerfile是一个文本文档，其中包含用户可以在命令行上调用以组装映像的所有命令。使用docker build的用户可以创建自动执行的构建，该构建可以连续执行几个命令行指令。</p>
<h2 id="构建springboot项目模版">构建springboot项目模版</h2>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FROM openjdk:<span class="number">8</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"></span><br><span class="line">ARG JAR=app.jar</span><br><span class="line"></span><br><span class="line">ENV SPRING_PROFILES_ACTIVE=online</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line">RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><br><span class="line"></span><br><span class="line">ADD config/ /opt/app/</span><br><span class="line">ADD $JAR /opt/app/app.jar</span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">8080</span></span><br><span class="line">WORKDIR /opt/app/</span><br><span class="line"></span><br><span class="line">CMD [ <span class="string">"/usr/local/openjdk-8/bin/java"</span>, <span class="string">"-Djava.security.egd=file:/dev/urandom"</span>, <span class="string">"-jar"</span>, <span class="string">"/opt/app/app.jar"</span> ]</span><br></pre></td></tr></table></figure>
<h2 id="usage">usage</h2>
<p>demo:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;deploy.sh ready-to-deploy.jar .&#x2F;config-directory&#x2F; docker-cotainer-name</span><br></pre></td></tr></table></figure>
<p>SPRING_PROFILES_ACTIVE is “online”, Server port is config IN application-online.yml / application-online.properties with default.</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo和themes Next版本升级</title>
    <url>/2019/10/26/hexo%E5%92%8Cthemes-Next%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="hexo版本升级">hexo版本升级</h2>
<p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.npm i hexo-cli -g</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2.npm update</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3.hexo version</span><br></pre></td></tr></table></figure>
<p>发现版本还是原来的3.9.0，其实上面的更新命令并不是很准确。</p>
<a id="more"></a>
<ol>
<li><code>npm-check</code>检查更新<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br></pre></td></tr></table></figure>
</li>
<li><code>npm-upgrade</code>更新<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br></pre></td></tr></table></figure>
</li>
<li>更新全局包<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm update -g</span><br></pre></td></tr></table></figure>
</li>
<li>更新生产环境依赖包<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm update --save</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>再次<code>hexo version</code>查看版本，发现已经更新为4.2.2了。</p>
<h2 id="next版本更新">next版本更新</h2>
<p>在升级之前，建议大家先备份自己的博客仓库，万一搞坏了昵，岂不尴了个大尬，事实证明的确小编也入坑一次，在这里我只附上正确更新流程，至于踩坑记录我就不多说了，说多了都是泪啊😢<br>
操作步骤：</p>
<ol>
<li>下载新的Next主题，仓库地址为：<a href="https://github.com/theme-next/hexo-theme-next.git;" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next.git;</a></li>
<li>进入下载的文件夹，git bash here,<code>rm -rf .git</code>,因为它本身就是git仓库，不删除和你的博客仓库就会是两个分支，解决方式当然是删除.git文件夹了。</li>
<li>建议用Beyound Compare剪贴对比工具对比原next文件夹和新next文件夹下的不同，特别是next下的_config.yml,该删除的删除，该修改的修改;</li>
<li>整合完毕后将新下载的next目录替换原来的next目录,然后本地启动测试OK后推送上库。<br>
是不是看了我的文章之后觉得也挺简单的，其实就是如此简单，只要不进坑😄。</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabbitmq 学习</title>
    <url>/2019/09/28/rabbitmq-topicexchange/</url>
    <content><![CDATA[<h2 id="概念">概念</h2>
<p>RabbitMQ作为一个消息队列提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全可靠。消息(Message)由Client发送，RabbitMQ接收到消息之后通过交换机转发到对应的队列上面。Worker会从队列中获取未被读取的数据处理。谈到队列服务, 会有三个概念： 发消息者、队列、收消息者，RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在发消息者和 队列之间, 加入了交换器 (Exchange). 这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列。</p>
<a id="more"></a>
<h2 id="交换机">交换机</h2>
<p>交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。交换机有四种类型：Direct, topic, Headers and Fanout<br>
这里有一个比较重要的概念：路由键 。消息到交换机的时候，交互机会转发到对应的队列中，那么究竟转发到哪个队列，就要根据该路由键。</p>
<ul>
<li>Direct：direct 类型的行为是“先匹配, 再投送”. 即在绑定时设定一个 routing_key, 消息的routing_key 匹配时, 才会被交换器投送到绑定的队列中去.</li>
<li>Topic：按规则转发消息（最灵活）</li>
<li>Headers：设置 header attribute 参数类型的交换机</li>
<li>Fanout：转发消息到所有绑定队列</li>
</ul>
<h3 id="Direct-Exchange">Direct Exchange</h3>
<p>Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。</p>
<h3 id="Topic-Exchange">Topic Exchange</h3>
<p>Topic Exchange 转发消息主要是根据通配符。 在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。<br>
在这种交换机模式下：</p>
<ul>
<li>路由键必须是一串字符，用句号（.） 隔开，比如说 <a href="http://agreements.us" target="_blank" rel="noopener">agreements.us</a>，或者 agreements.eu.stockholm 等。</li>
<li>路由模式必须包含一个 星号（<em>），主要用于匹配路由键指定位置的一个单词，比如说，一个路由模式是这样子：agreements…b.</em>，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin 开头的路由键都是可以的。</li>
</ul>
<ul>
<li>*表示一个词.</li>
<li>#表示零个或多个词.</li>
</ul>
<h3 id="Headers-Exchange">Headers Exchange</h3>
<p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型. 在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.</p>
<h3 id="Fanout-Exchange">Fanout Exchange</h3>
<p>Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，会把消息发给绑定给它的全部队列，如果配置了 routing_key 会被忽略。</p>
<h2 id="代码示例-TopicExchange">代码示例(TopicExchange)</h2>
<p>pom.xm加入依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">      &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>application.yml添加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure>
<p><code>TopicRabbitMqConfig.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.study.rabbitmq.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitMqConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_ONE = <span class="string">"topic.one"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_TWO = <span class="string">"topic.two"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_EXCHANGE = <span class="string">"topicExchange"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Topic 交换机模式  可以用通配符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个 Queue</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue_one</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_ONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue_two</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_TWO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 TopicExchange,指定名称为 topicExchange</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPIC_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给队列绑定 exchange 和 routing_key</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeMessage</span><span class="params">(Queue queue_one, TopicExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue_one).to(exchange).with(<span class="string">"topic.one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bingingExchangeMessages</span><span class="params">(Queue queue_two,TopicExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue_two).to(exchange).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TopicSender.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.study.rabbitmq.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send_one</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String context = <span class="string">"Hi,I am message one"</span>;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(TopicRabbitMqConfig.TOPIC_EXCHANGE,<span class="string">"topic.one"</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send_two</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String context = <span class="string">"Hi,I am message two"</span>;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(TopicRabbitMqConfig.TOPIC_EXCHANGE,<span class="string">"topic.two"</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TopicReceiver1.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.study.rabbitmq.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"topic.one"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReceiver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver1 topic.one :"</span>+ message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TopicReceiver2.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.study.rabbitmq.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"topic.two"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReceiver2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver2 topic.two :"</span>+ message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RabbitmqdemoApplicationTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RabbitmqdemoApplicationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TopicSender topicSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        topicSender.send_one();</span><br><span class="line">        topicSender.send_two();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>topicSender.send_one()</code>打印日志如下:<br>
<img src="/images/topic1.png" alt=""><br>
<code>topicSender.send_two()</code>打印如下：<br>
<img src="/images/topic2.png" alt=""><br>
由此可说明发送send_one会匹配到topic.#和topic.one,所以两个Receiver都可以收到消息，发送send_two只有topic.#可以匹配所有,只有Receiver2监听到消息。</p>
]]></content>
      <categories>
        <category>RabbitMq</category>
      </categories>
      <tags>
        <tag>RabbitMq</tag>
      </tags>
  </entry>
  <entry>
    <title>初识SpringCloud</title>
    <url>/2019/09/07/springcloud-learn/</url>
    <content><![CDATA[<h2 id="开篇">开篇</h2>
<p>SpringCloud越来越火，咱也得跟上潮流啊，闲暇之余，自己学习并代码实战了下，其实发现并不难，知道其各个模块是干什么的并且能够运用就够了，下面我就简单说下自己学习过程的心得，也算是总结一下。</p>
<h2 id="微服务">微服务</h2>
<p>简而言之，微服务架构风格是一种将单个应用程序作为一套小型服务开发的方法，每种应用程序都在自己的进程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。 这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署。 这些服务的集中管理最少，可以用不同的编程语言编写，并使用不同的数据存储技术。</p>
<a id="more"></a>
<h2 id="为什么要用微服务">为什么要用微服务</h2>
<p>特点：<br>
1、独立部署，灵活扩展<br>
2、资源的有效隔离<br>
3、团队组织架构的调整<br>
和soa的区别：<br>
soa架构是一种粗粒度松耦合的服务架构，SOA架构强调的是异构系统之间的通信和解耦合，而微服务架构强调的是系统按业务边界做细粒度的拆分和部署。</p>
<h2 id="微服务组件">微服务组件</h2>
<h3 id="包含的主要组件以及各组件主要是干什么的">包含的主要组件以及各组件主要是干什么的</h3>
<p><code>Eureka</code>、<code>Ribbon</code>、<code>Feign</code>、<code>Hystrix</code>、<code>Zuul</code>这几个组件</p>
<h4 id="一、Eureka-服务注册与发现。包含Eureka-Server和Eureka-Client">一、Eureka:服务注册与发现。包含Eureka Server和Eureka Client</h4>
<p>Eureka Server:注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号.<br>
Eureka Client:负责将这个服务的信息注册到Eureka Server中</p>
<h4 id="二、Feign-关键机制就是使用了动态代理">二、Feign:关键机制就是使用了动态代理</h4>
<p>过程：<br>
首先，如果你对某个接口定义了<code>@FeignClient</code>注解，Feign就会针对这个接口创建一个动态代理<br>
接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心<br>
<code>Feign</code>的动态代理会根据你在接口上的<code>@RequestMapping</code>等注解，来动态构造出你要请求的服务的地址<br>
最后针对这个地址，发起请求、解析响应</p>
<h4 id="三、Ribbon-负载均衡。假如一个服务部署到几台服务器上，它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上。">三、Ribbon:负载均衡。假如一个服务部署到几台服务器上，它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上。</h4>
<h4 id="四、断路器（Hystrix）">四、断路器（Hystrix）</h4>
<p>这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求，造成服务雪崩问题。<br>
<code>Hystrix</code>是隔离、熔断以及降级的一个框架。说白了，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。<br>
就是对请求的已经挂了的服务直接返回错误，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断。咱不单单只是直接返回错误，这样也没有太大的意义，还要处理点什么，比如，在数据库里增加一条记录，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。</p>
<h4 id="五、服务网关（Zuul）">五、服务网关（Zuul）</h4>
<p>一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。<br>
而且有一个网关之后，还有很多好处，比如可以做统一的降级、限流、认证授权、安全，等等。</p>
<h4 id="六、服务配置中心-（Spring-Cloud-Config）">六、服务配置中心 （Spring Cloud Config）</h4>
<p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p>
<h4 id="七、服务链路追踪（Spring-Cloud-Sleuth）">七、服务链路追踪（Spring Cloud Sleuth）</h4>
<p><code>Spring Cloud Sleuth </code>主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 <code>Zipkin</code>，你只需要在pom文件中引入相应的依赖即可。服务间相互调用，<code>Zipkin</code>收集数据.</p>
<h4 id="八、-消息总线（Spring-Cloud-Bus）">八、 消息总线（Spring Cloud Bus）</h4>
<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。例如github上的配置文件有更新时，只需发送请求/bus/refresh/,再请求配置文件发现内容已更新。</p>
<h4 id="九、高可用的服务中心：Eureka通过运行多个实例，使其更具有高可用性。事实上，这是它默认的熟性，你需要做的就是给对等的实例一个合法的关联serviceurl。简单来说就是建多个服务注册中心，具体做法就是写多个application-xx-yml-改变etc-hosts，linux系统通过vim-etc-hosts-加上：127-0-0-1-xx-127-0-0-1-yy-xx-yy就是你application的后缀名-windows电脑，在c-windows-systems-drivers-etc-hosts-修改。启动工程：">九、高可用的服务中心：Eureka通过运行多个实例，使其更具有高可用性。事实上，这是它默认的熟性，你需要做的就是给对等的实例一个合法的关联serviceurl。简单来说就是建多个服务注册中心，具体做法就是写多个application_xx.yml,改变etc/hosts，linux系统通过vim /etc/hosts ,加上：127.0.0.1 xx , 127.0.0.1 yy(xx,yy就是你application的后缀名),windows电脑，在c:/windows/systems/drivers/etc/hosts 修改。启动工程：</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=xx</span><br><span class="line">java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=yy</span><br></pre></td></tr></table></figure>
<p>Eureka-eserver xx ,Eureka-eserver yy 相互感应，当有服务注册时，两个Eureka-eserver是对等的，它们都存有相同的信息。这就是通过服务器的冗余来增加可靠性，当有一台服务器宕机了，服务并不会终止，因为另一台服务存有相同的数据。</p>
<h4 id="断路器聚合监控（Hystrix-Turbine）">断路器聚合监控（Hystrix Turbine）</h4>
<p>看单个的<code>Hystrix Dashboard</code>的数据并没有什么多大的价值，要想看这个系统的Hystrix Dashboard数据就需要用到<code>Hystrix Turbine</code>。<code>Hystrix Turbine</code>将每个服务<code>Hystrix Dashboard</code>数据进行了整合。<code>Hystrix Turbine</code>的使用非常简单，只需要引入相应的依赖和加上注解和配置就可以了。</p>
<h4 id="网关（Spring-Cloud-Gateway）">网关（Spring Cloud Gateway）</h4>
<p><code>Spring Cloud Gateway</code>是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。</p>
<h2 id="Tips">Tips</h2>
<ul>
<li>搭建springcloud的modules时，父模块打包方式是pom,子模块为jar</li>
<li>父模块不需要增加构建插件maven-plugin，公共模块提取出单独作为一个module时，也不需要maven-plugin；子模块作为父模块其下又有子模块，则这个子模块不需要添加maven-plugin,打包方式为pom,除此之外,其它均需maven-plugin<br>
maven示例请查阅<a href="">下篇文章</a>。</li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>极光推送服务端集成</title>
    <url>/2019/08/30/jpush/</url>
    <content><![CDATA[<h2 id="开篇">开篇</h2>
<p>有不少公司在选择推送平台的时候都选择了极光推送（好像用友的也不错。只是没用过），之前我也做过一个php服务端极光推送的集成，但是这里昵我要说的是java服务端的集成，做过两次，这才想起来整理一下，供给有需求的朋友satisfied:，虽然没几个人看。</p>
<h2 id="代码集成">代码集成</h2>
<p>在application.yml里配置一下jpush平台你所创建的应用的配置信息，如下图：</p>
<a id="more"></a>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">jpush:</span><br><span class="line">  appKey: ########</span><br><span class="line">  masterSecret: ##################</span><br><span class="line">  apnsProduction: false   # 是否生产环境，true表示生产环境</span><br></pre></td></tr></table></figure>
<p>JpushUtil.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xy.goone.common.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jiguang.common.resp.APIConnectionException;</span><br><span class="line"><span class="keyword">import</span> cn.jiguang.common.resp.APIRequestException;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.JPushClient;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.PushResult;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.model.Message;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.model.Options;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.model.Platform;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.model.PushPayload;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.model.audience.Audience;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.model.notification.AndroidNotification;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.model.notification.IosAlert;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.model.notification.IosNotification;</span><br><span class="line"><span class="keyword">import</span> cn.jpush.api.push.model.notification.Notification;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fumei.jiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-13 13:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 极光推送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JPushUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jpush.appKey&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String appKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jpush.masterSecret&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String masterSecret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jpush.apnsProduction&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> apnsProduction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JPushClient jPushClient = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESPONSE_OK = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JPushClient <span class="title">getJPushClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jPushClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jPushClient = <span class="keyword">new</span> JPushClient(masterSecret, appKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jPushClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 推送到alias列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alias             别名或别名组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> title 通知标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   通知内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extras        扩展字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PushPayload <span class="title">sendToAliasList</span><span class="params">(List&lt;String&gt; alias,String unique, String title, String content, Map&lt;String,String&gt; extras)</span> </span>&#123;</span><br><span class="line">        PushPayload pushPayload = buildPushObject_android_and_ios(Audience.alias(alias),unique,title, content, extras);</span><br><span class="line">        <span class="keyword">this</span>.sendPush(pushPayload);</span><br><span class="line">        <span class="keyword">return</span> pushPayload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 推送到tag列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tagsList          Tag或Tag组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> title 通知标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   通知内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extras        扩展字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToTagsList</span><span class="params">(List&lt;String&gt; tagsList, String unique, String title, String content, Map&lt;String,String&gt; extras)</span> </span>&#123;</span><br><span class="line">        PushPayload pushPayload = buildPushObject_android_and_ios(Audience.tag(tagsList),<span class="keyword">null</span>, title, content, extras);</span><br><span class="line">        <span class="keyword">this</span>.sendPush(pushPayload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送给所有安卓用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> notificationTitle 通知内容标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgTitle          消息内容标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgContent        消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extras            扩展字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToAllAndroid</span><span class="params">(String notificationTitle, String msgTitle, String msgContent, String extras)</span> </span>&#123;</span><br><span class="line">        PushPayload pushPayload = buildPushObject_android_all_alertWithTitle(notificationTitle, msgTitle, msgContent, extras);</span><br><span class="line">        <span class="keyword">this</span>.sendPush(pushPayload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送给所有IOS用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> notificationTitle 通知内容标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgTitle          消息内容标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgContent        消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extras            扩展字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToAllIOS</span><span class="params">(String notificationTitle, String msgTitle, String msgContent, String extras)</span> </span>&#123;</span><br><span class="line">        PushPayload pushPayload = buildPushObject_ios_all_alertWithTitle(notificationTitle, msgTitle, msgContent, extras);</span><br><span class="line">        <span class="keyword">this</span>.sendPush(pushPayload);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送给所有用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> title 通知标题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   通知内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extras        扩展字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToAll</span><span class="params">(String unique, String title, String content, Map&lt;String,String&gt; extras)</span> </span>&#123;</span><br><span class="line">        PushPayload pushPayload = buildPushObject_android_and_ios(Audience.all(),unique, title, content, extras);</span><br><span class="line">        <span class="keyword">this</span>.sendPush(pushPayload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PushResult <span class="title">sendPush</span><span class="params">(PushPayload pushPayload)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"pushPayload=&#123;&#125;"</span>, pushPayload);</span><br><span class="line">        PushResult pushResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pushResult = <span class="keyword">this</span>.getJPushClient().sendPush(pushPayload);</span><br><span class="line">            log.info(<span class="string">""</span> + pushResult);</span><br><span class="line">            <span class="keyword">if</span> (pushResult.getResponseCode() == RESPONSE_OK) &#123;</span><br><span class="line">                log.info(<span class="string">"push successful, pushPayload=&#123;&#125;"</span>, pushPayload);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (APIConnectionException e) &#123;</span><br><span class="line">            log.error(<span class="string">"push failed: pushPayload=&#123;&#125;, exception=&#123;&#125;"</span>, pushPayload, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (APIRequestException e) &#123;</span><br><span class="line">            log.error(<span class="string">"push failed: pushPayload=&#123;&#125;, exception=&#123;&#125;"</span>, pushPayload, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pushResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unique</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> title</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extras</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PushPayload <span class="title">buildPushObject_android_and_ios</span><span class="params">(Audience filter,String unique, String title, String content, Map&lt;String,String&gt; extras)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PushPayload.newBuilder()</span><br><span class="line">                .setCid(unique)</span><br><span class="line">                .setPlatform(Platform.android_ios())</span><br><span class="line">                .setAudience(filter)</span><br><span class="line">                .setNotification(Notification.newBuilder()</span><br><span class="line">                        .addPlatformNotification(AndroidNotification.newBuilder()</span><br><span class="line">                                .setTitle(title)</span><br><span class="line">                                .setAlert(content)</span><br><span class="line">                                <span class="comment">// 此字段为透传字段，不会显示在通知栏。用户可以通过此字段来做一些定制需求，如特定的key传要指定跳转的页面（value）</span></span><br><span class="line">                                .addExtras(extras)</span><br><span class="line">                                .build()</span><br><span class="line">                        )</span><br><span class="line">                        .addPlatformNotification(IosNotification.newBuilder()</span><br><span class="line">                                <span class="comment">// 传一个IosAlert对象，指定apns title、title、subtitle等</span></span><br><span class="line">                                .setAlert(IosAlert.newBuilder()</span><br><span class="line">                                        .setTitleAndBody(title, <span class="keyword">null</span>, content)</span><br><span class="line">                                        .build())</span><br><span class="line">                                <span class="comment">// 直接传alert</span></span><br><span class="line">                                <span class="comment">// 此项是指定此推送的badge自动加1</span></span><br><span class="line">                                .incrBadge(<span class="number">1</span>)</span><br><span class="line">                                <span class="comment">// 此字段的值default表示系统默认声音；传sound.caf表示此推送以项目里面打包的sound.caf声音来提醒，</span></span><br><span class="line">                                <span class="comment">// 如果系统没有此音频则以系统默认声音提醒；此字段如果传空字符串，iOS9及以上的系统是无声音提醒，以下的系统是默认声音</span></span><br><span class="line">                                .setSound(<span class="string">"default"</span>)</span><br><span class="line">                                <span class="comment">// 此字段为透传字段，不会显示在通知栏。用户可以通过此字段来做一些定制需求，如特定的key传要指定跳转的页面（value）</span></span><br><span class="line">                                .addExtras(extras)</span><br><span class="line">                                <span class="comment">// 此项说明此推送是一个background推送，想了解background看：http://docs.jpush.io/client/ios_tutorials/#ios-7-background-remote-notification</span></span><br><span class="line">                                <span class="comment">// .setContentAvailable(true)</span></span><br><span class="line">                                .build()</span><br><span class="line">                        )</span><br><span class="line">                        .build()</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">// Platform指定了哪些平台就会像指定平台中符合推送条件的设备进行推送。 jpush的自定义消息，</span></span><br><span class="line">                <span class="comment">// sdk默认不做任何处理，不会有通知提示。建议看文档http://docs.jpush.io/guideline/faq/的</span></span><br><span class="line">                <span class="comment">// [通知与自定义消息有什么区别？]了解通知和自定义消息的区别</span></span><br><span class="line">                .setOptions(Options.newBuilder()</span><br><span class="line">                        <span class="comment">// 此字段的值是用来指定本推送要推送的apns环境，false表示开发，true表示生产；对android和自定义消息无意义</span></span><br><span class="line">                        .setApnsProduction(apnsProduction)</span><br><span class="line">                        <span class="comment">// 此字段是给开发者自己给推送编号，方便推送者分辨推送记录</span></span><br><span class="line">                        .setSendno(<span class="number">1</span>)</span><br><span class="line">                        <span class="comment">// 此字段的值是用来指定本推送的离线保存时长，如果不传此字段则默认保存一天，最多指定保留十天，单位为秒</span></span><br><span class="line">                        .setTimeToLive(<span class="number">86400</span>)</span><br><span class="line">                        .build())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向android平台所有用户推送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> notificationTitle</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgTitle</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgContent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extras</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PushPayload <span class="title">buildPushObject_android_all_alertWithTitle</span><span class="params">(String notificationTitle, String msgTitle, String msgContent, String extras)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PushPayload.newBuilder()</span><br><span class="line">                <span class="comment">// 指定要推送的平台，all代表当前应用配置了的所有平台，也可以传android等具体平台</span></span><br><span class="line">                .setPlatform(Platform.android())</span><br><span class="line">                <span class="comment">// 指定推送的接收对象，all代表所有人，也可以指定已经设置成功的tag或alias或该应应用客户端调用接口获取到的registration id</span></span><br><span class="line">                .setAudience(Audience.all())</span><br><span class="line">                <span class="comment">// jpush的通知，android的由jpush直接下发，iOS的由apns服务器下发，Winphone的由mpns下发</span></span><br><span class="line">                .setNotification(Notification.newBuilder()</span><br><span class="line">                        <span class="comment">// 指定当前推送的android通知</span></span><br><span class="line">                        .addPlatformNotification(AndroidNotification.newBuilder()</span><br><span class="line">                                .setAlert(notificationTitle)</span><br><span class="line">                                .setTitle(notificationTitle)</span><br><span class="line">                                <span class="comment">// 此字段为透传字段，不会显示在通知栏。用户可以通过此字段来做一些定制需求，如特定的key传要指定跳转的页面（value）</span></span><br><span class="line">                                .addExtra(<span class="string">"androidNotification extras key"</span>, extras)</span><br><span class="line">                                .build())</span><br><span class="line">                        .build()</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">// Platform指定了哪些平台就会像指定平台中符合推送条件的设备进行推送。 jpush的自定义消息，</span></span><br><span class="line">                <span class="comment">// sdk默认不做任何处理，不会有通知提示。建议看文档http://docs.jpush.io/guideline/faq/的</span></span><br><span class="line">                <span class="comment">// [通知与自定义消息有什么区别？]了解通知和自定义消息的区别</span></span><br><span class="line">                .setMessage(Message.newBuilder()</span><br><span class="line">                        .setMsgContent(msgContent)</span><br><span class="line">                        .setTitle(msgTitle)</span><br><span class="line">                        .addExtra(<span class="string">"message extras key"</span>, extras)</span><br><span class="line">                        .build())</span><br><span class="line"></span><br><span class="line">                .setOptions(Options.newBuilder()</span><br><span class="line">                        <span class="comment">// 此字段的值是用来指定本推送要推送的apns环境，false表示开发，true表示生产；对android和自定义消息无意义</span></span><br><span class="line">                        .setApnsProduction(apnsProduction)</span><br><span class="line">                        <span class="comment">// 此字段是给开发者自己给推送编号，方便推送者分辨推送记录</span></span><br><span class="line">                        .setSendno(<span class="number">1</span>)</span><br><span class="line">                        <span class="comment">// 此字段的值是用来指定本推送的离线保存时长，如果不传此字段则默认保存一天，最多指定保留十天，单位为秒</span></span><br><span class="line">                        .setTimeToLive(<span class="number">86400</span>)</span><br><span class="line">                        .build())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向ios平台所有用户推送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> notificationTitle</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgTitle</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgContent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extras</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PushPayload <span class="title">buildPushObject_ios_all_alertWithTitle</span><span class="params">(String notificationTitle, String msgTitle, String msgContent, String extras)</span> </span>&#123;</span><br><span class="line">        PushPayload.Builder load = PushPayload.newBuilder()</span><br><span class="line">                <span class="comment">// 指定要推送的平台，all代表当前应用配置了的所有平台，也可以传android等具体平台</span></span><br><span class="line">                .setPlatform(Platform.ios())</span><br><span class="line">                <span class="comment">// 指定推送的接收对象，all代表所有人，也可以指定已经设置成功的tag或alias或该应应用客户端调用接口获取到的registration id</span></span><br><span class="line">                .setAudience(Audience.all())</span><br><span class="line">                <span class="comment">// jpush的通知，android的由jpush直接下发，iOS的由apns服务器下发，Winphone的由mpns下发</span></span><br><span class="line">                .setNotification(Notification.newBuilder()</span><br><span class="line">                        <span class="comment">// 指定当前推送的android通知</span></span><br><span class="line">                        .addPlatformNotification(IosNotification.newBuilder()</span><br><span class="line">                                <span class="comment">// 传一个IosAlert对象，指定apns title、title、subtitle等</span></span><br><span class="line">                                .setAlert(notificationTitle)</span><br><span class="line">                                <span class="comment">// 直接传alert</span></span><br><span class="line">                                <span class="comment">// 此项是指定此推送的badge自动加1</span></span><br><span class="line">                                .incrBadge(<span class="number">1</span>)</span><br><span class="line">                                <span class="comment">// 此字段的值default表示系统默认声音；传sound.caf表示此推送以项目里面打包的sound.caf声音来提醒，</span></span><br><span class="line">                                <span class="comment">// 如果系统没有此音频则以系统默认声音提醒；此字段如果传空字符串，iOS9及以上的系统是无声音提醒，以下的系统是默认声音</span></span><br><span class="line">                                .setSound(<span class="string">"default"</span>)</span><br><span class="line">                                <span class="comment">// 此字段为透传字段，不会显示在通知栏。用户可以通过此字段来做一些定制需求，如特定的key传要指定跳转的页面（value）</span></span><br><span class="line">                                .addExtra(<span class="string">"extras"</span>, extras)</span><br><span class="line">                                <span class="comment">// 此项说明此推送是一个background推送，想了解background看：http://docs.jpush.io/client/ios_tutorials/#ios-7-background-remote-notification</span></span><br><span class="line">                                <span class="comment">// .setContentAvailable(true)</span></span><br><span class="line">                                .build())</span><br><span class="line">                        .build()</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// Platform指定了哪些平台就会像指定平台中符合推送条件的设备进行推送。 jpush的自定义消息，</span></span><br><span class="line">        <span class="comment">// sdk默认不做任何处理，不会有通知提示。建议看文档http://docs.jpush.io/guideline/faq/的</span></span><br><span class="line">        <span class="comment">// [通知与自定义消息有什么区别？]了解通知和自定义消息的区别</span></span><br><span class="line">        load.setMessage(Message.newBuilder()</span><br><span class="line">                .setTitle(msgTitle)</span><br><span class="line">                .setMsgContent(msgContent)</span><br><span class="line">                .addExtra(<span class="string">"extras"</span>, extras)</span><br><span class="line">                .build())</span><br><span class="line">                .setOptions(Options.newBuilder()</span><br><span class="line">                        <span class="comment">// 此字段的值是用来指定本推送要推送的apns环境，false表示开发，true表示生产;如果不显式设置的话，Library 会默认指定为开发;对android和自定义消息无意义</span></span><br><span class="line">                        .setApnsProduction(apnsProduction)</span><br><span class="line">                        <span class="comment">// 此字段是给开发者自己给推送编号，方便推送者分辨推送记录</span></span><br><span class="line">                        .setSendno(<span class="number">1</span>)</span><br><span class="line">                        <span class="comment">// 此字段的值是用来指定本推送的离线保存时长，如果不传此字段则默认保存一天，最多指定保留十天，单位为秒</span></span><br><span class="line">                        .setTimeToLive(<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) <span class="comment">// 1天</span></span><br><span class="line">                        .build());</span><br><span class="line">        <span class="keyword">return</span> load.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>第三方</category>
      </categories>
      <tags>
        <tag>第三方</tag>
        <tag>JPush</tag>
      </tags>
  </entry>
  <entry>
    <title>函数和方法</title>
    <url>/2019/07/15/java8-method/</url>
    <content><![CDATA[<h1>Java中的函数</h1>
<h2 id="方法引用">方法引用:</h2>
<p>比方说，你想要筛选一个目录中的所有隐藏文件。你需要编写一个方法，然后给它一个<code>File</code>，它就会告诉你文件是不是隐藏的。幸好，File类里面有一个叫作<code>isHidden</code>的方法。我们可以把它看作一个函数，接受一个<code>File</code>，返回一个布尔值。但要用它做筛选，你需要把它包在一个<code>FileFilter</code>对象里，然后传递给<code>File.listFiles</code>方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File[] hiddenFiles = <span class="keyword">new</span> File(<span class="string">"."</span>).listFiles(<span class="keyword">new</span> FileFilter() &#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> file.isHidden(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>我们已经有一个方法isHidden可以使用，为什么非得把它包在一个啰嗦的FileFilter类里面再实例化呢？因为在Java 8之前你必须这么做！如今在Java 8里，你可以把代码重写成这个样子：<br>
<code>File[] hiddenFiles = new File(&quot;.&quot;).listFiles(File::isHidden);</code><br>
你已经有了函数isHidden，因此只需用Java 8的方法引用::语法（即“把这个方法作为值”）将其传给listFiles方法；请注意，我们也开始用函数代表方法了。一个好处是，你的代码现在读起来更接近问题的陈述了。方法不再是二等值了。与用对象引用传递对象类似（对象引用是用new创建的），在<code>Java 8</code>里写下 <code>File::isHidden</code> 的时候，你就创建了一个方法引用，你同样可以传递它。</p>
<h2 id="Lambda——匿名函数">Lambda——匿名函数</h2>
<p>假设你有一个Apple类，它有一个getColor方法，还有一个变量inventory保存着一个Apples的列表。你可能想要选出所有的绿苹果，并返回一个列表。通常我们用筛选（filter）一词来表达这个概念。在Java 8之前，你可能会写这样一个方法<code>filterGreenApples</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterGreenApples</span><span class="params">(List&lt;Apple&gt; inventory)</span></span>&#123; </span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">for</span> (Apple apple: inventory)&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"green"</span>.equals(apple.getColor())) &#123;</span><br><span class="line">            result.add(apple); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是接下来，有人可能想要选出重的苹果，比如超过150克，于是你心情沉重地写了下面这个方法，甚至用了复制粘贴：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterHeavyApples</span><span class="params">(List&lt;Apple&gt; inventory)</span></span>&#123; </span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">for</span> (Apple apple: inventory)&#123; </span><br><span class="line">        <span class="keyword">if</span> (apple.getWeight() &gt; <span class="number">150</span>) &#123; </span><br><span class="line">            result.add(apple); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘿，这两个方法只有一行不同：if里面高亮的那行条件。如果这两个高亮的方法之间的差异仅仅是接受的重量范围不同，那么你只要把接受的重量上下限作为参数传递给filter就行了，比如指定(150, 1000)来选出重的苹果（超过150克），或者指定(0, 80)来选出轻的苹果（低于80克）。但是，我们前面提过了，Java 8会把条件代码作为参数传递进去，这样可以避免filter方法出现重复的代码。现在你可以写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGreenApple</span><span class="params">(Apple apple)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">"green"</span>.equals(apple.getColor());</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHeavyApple</span><span class="params">(Apple apple)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApples</span><span class="params">(List&lt;Apple&gt; inventory, Predicate&lt;Apple&gt; p)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">for</span> (Apple apple: inventory)&#123; </span><br><span class="line">        <span class="keyword">if</span> (p.test(apple)) &#123; </span><br><span class="line">            result.add(apple); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要用它的话，你可以写：<code>filterApples(inventory, Apple::isGreenApple)</code>; 或者<code>filterApples(inventory, Apple::isHeavyApple)</code>;</p>
<p><strong>什么是谓词？前面的代码传递了方法 Apple::isGreenApple （它接受参数 Apple 并返回一个boolean）给filterApples，后者则希望接受一个Predicate<Apple>参数。谓词（predicate）在数学上常常用来代表一个类似函数的东西，它接受一个参数值，并返回true或false。你在后面会看到，Java 8也会允许你写Function&lt;Apple,Boolean&gt;——在学校学过函数却没学过谓词的读者对此可能更熟悉，但用Predicate<Apple>是更标准的方式，效率也会更高一点儿，这避免了把boolean封装在Boolean里面。</strong></p>
<h2 id="从传递方法到-Lambda">从传递方法到 Lambda</h2>
<p>把方法作为值来传递显然很有用，但要是为类似于isHeavyApple和isGreenApple这种可能只用一两次的短方法写一堆定义有点儿烦人。不过Java 8也解决了这个问题，它引入了一套新记法（匿名函数或Lambda），让你可以写<br>
<code>filterApples(inventory, (Apple a) -&gt; &quot;green&quot;.equals(a.getColor()) )</code>;<br>
或者<br>
<code>filterApples(inventory, (Apple a) -&gt; a.getWeight() &gt; 150 )</code>;<br>
甚至<br>
<code>filterApples(inventory, (Apple a) -&gt; a.getWeight() &lt; 80 || &quot;brown&quot;.equals(a.getColor()) )</code>;<br>
所以，你甚至都不需要为只用一次的方法写定义；代码更干净、更清晰，因为你用不着去找自己到底传递了什么代码。<strong>但要是Lambda的长度多于几行，还是应该用方法引用来指向一个有描述性名称的方法，而不是使用匿名Lambda,应该以代码清晰为准绳.</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java8新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>流</title>
    <url>/2019/07/15/java8-stream/</url>
    <content><![CDATA[<h1>流(1)</h1>
<p>几乎每个Java应用都会制造和处理集合。但集合用起来并不总是那么理想。比方说，你需要从一个列表中筛选金额较高的交易，然后按货币分组。你需要写一大堆套路化的代码来实现这个数据处理命令，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line"><span class="keyword">for</span> (Transaction transaction : transactions) &#123; </span><br><span class="line">        <span class="keyword">if</span>(transaction.getPrice() &gt; <span class="number">1000</span>)&#123; </span><br><span class="line">            Currency currency = transaction.getCurrency(); </span><br><span class="line">            List&lt;Transaction&gt; transactionsForCurrency = transactionsByCurrencies.get(currency); </span><br><span class="line">            <span class="keyword">if</span> (transactionsForCurrency == <span class="keyword">null</span>) &#123; </span><br><span class="line">                transactionsForCurrency = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">                transactionsByCurrencies.put(currency, transactionsForCurrency); </span><br><span class="line">            &#125; </span><br><span class="line">        transactionsForCurrency.add(transaction); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>此外，我们很难一眼看出来这些代码是做什么的，因为有好几个嵌套的控制流指令。有了<code>Stream API</code>，你现在可以这样解决这个问题了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList; </span><br><span class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = transactions.stream() .filter((Transaction t) -&gt; t.getPrice() &gt; <span class="number">1000</span>) .collect(groupingBy(Transaction::getCurrency));</span><br></pre></td></tr></table></figure>
<p>现在值得注意的是，和Collection API相比，Stream API处理数据的方式非常不同。用集合的话，你得自己去做迭代的过程。你得用for-each循环一个个去迭代元素，然后再处理元素。我们把这种数据迭代的方法称为<strong>外部迭代</strong>,相反，有了Stream API，你根本用不着操心循环的事情。数据处理完全是在库内部进行的。我们把这种思想叫作<strong>内部迭代</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java8新特性</category>
      </categories>
      <tags>
        <tag>Java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式</title>
    <url>/2019/01/03/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Design类型，共23种：">Design类型，共23种：</h2>
<p>**创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。<br>
**结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。<br>
**行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。<br>
设计原则：</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA hibernate的持久化生命状态</title>
    <url>/2019/01/02/jpa%E6%8C%81%E4%B9%85%E5%8C%96%E7%94%9F%E5%91%BD%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="开篇">开篇</h2>
<p>某日写程序时，使用jpa操作数据库，当我使用<code>findAll（）</code>方法查处一个List的对象后，给对这个list的实体进行了一些操作，并没有调用<code>update</code> 或者 <code>saveOrUpdate</code>方法，更改后的数据却神奇的保存到数据库里面去了😕😕😕我也在service层添加事物了啊。后面找了资料才发现是jpa是对hibernate的封装，底层是hibernate，这是hibernate的持久状态搞的鬼。</p>
<a id="more"></a>
<h2 id="hibernate-的三种状态">hibernate 的三种状态</h2>
<ol>
<li><strong>瞬时状态 (Transient)</strong><br>
当我们通过Java的new关键字来生成一个实体对象时，这时这个实体对象就处于自由状态，如下：<br>
<code>People people=new People(“xs”,20);</code><br>
此时people只是通过JVM获得了一块内存空间，还并没有通过Session对象的save()方法保存进数据库，因此也就还没有纳入Hibernate的缓存管理中，也就是说customer对象现在还自由的游荡于Hibernate缓存管理之外。所以我们可以看出自由对象最大的特点就是，在数据库中不存在一条与它对应的记录。<br>
瞬时对象特点：<br>
<strong>不和 Session 实例关联</strong><br>
<strong>在数据库中没有和瞬时对象关联的记录</strong></li>
<li><strong>持久状态 (Persistent)</strong><br>
持久化对象就是已经被保存进数据库的实体对象，并且这个实体对象现在还处于Hibernate的缓存管理之中。这是对该实体对象的任何修改，都会在清理缓存时同步到数据库中。如下所示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">People people=<span class="keyword">new</span> People(“xs”,<span class="number">20</span>);</span><br><span class="line">tx=session.beginTransaction();</span><br><span class="line">session.save(people);</span><br><span class="line">customer=(Customer)session.load(Customer<span class="class">.<span class="keyword">class</span>,”1”)</span>;</span><br><span class="line">customer.setAge(<span class="number">28</span>);</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure>
<p>这时我们并没有显示调用<code>session.update()</code>方法来保存更新，但是对实体对象的修改还是会同步更新到数据库中，因为此时customer对象通过save方法保存进数据库后，已经是持久化对象了，然后通过load方法再次加载它，它仍然是持久化对象，所以它还处于Hibernate缓存的管理之中，这时当执行<code>tx.commit()</code>方法时，<code>Hibernate</code>会自动清理缓存，并且自动将持久化对象的属性变化同步到到数据库中。<br>
持久的实例在数据库中有对应的记录，并拥有一个持久化标识 (identifier).持久对象总是与 <code>Session</code> 和 <code>Transaction</code> 相关联，在一个<code> Session</code> 中，对持久对象的改变不会马上对数据库进行变更，而必须在<code>Transaction</code>终止，也就是执行<code> commit()</code> 之后，才在数据库中真正运行 SQL 进行变更，持久对象的状态才会与数据库进行同步。在同步之前的持久对象称为脏 (dirty) 对象。<br>
瞬时对象转为持久对象：<br>
通过 <code>Session</code> 的 <code>save()</code> 和 <code>saveOrUpdate() </code>方法把一个瞬时对象与数据库相关联，这个瞬时对象就成为持久化对象。<br>
使用 <code>fine()</code>,<code>get()</code>,<code>load()</code> 和 <code>iterater()</code> 待方法查询到的数据对象，将成为持久化对象。<br>
持久化对象的特点：<br>
<strong>和 Session 实例关联</strong><br>
<strong>在数据库中有和持久对象关联的记录</strong><br>
3. <strong>脱管状态 (Detached)</strong><br>
当一个持久化对象，脱离开Hibernate的缓存管理后，它就处于游离状态，游离对象和自由对象的最大区别在于，游离对象在数据库中可能还存在一条与它对应的记录，只是现在这个游离对象脱离了Hibernate的缓存管理，而自由对象不会在数据库中出现与它对应的数据记录。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">People people=<span class="keyword">new</span> People(“xs”,<span class="number">20</span>);</span><br><span class="line">tx=session.beginTransaction();</span><br><span class="line">session.save(people);</span><br><span class="line">people=(People)session.load(People<span class="class">.<span class="keyword">class</span>,”1”)</span>;</span><br><span class="line">people.setAge(<span class="number">28</span>);</span><br><span class="line">tx.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure>
<p>当session关闭后，customer对象就不处于Hibernate的缓存管理之中了，但是此时在数据库中还存在一条与customer对象对应的数据记录，所以此时customer对象处于游离态<br>
与持久对象关联的 Session 被关闭后，对象就变为脱管对象。对脱管对象的引用依然有效，对象可继续被修改。<br>
脱管对象特点：<br>
<strong>本质上和瞬时对象相同</strong><br>
<strong>只是比瞬时对象多了一个数据库记录标识值 id</strong>.<br>
持久对象转为脱管对象：<br>
当执行 <code>close() </code>或 <code>clear()</code>,<code>evict()</code> 之后，持久对象会变为脱管对象。<br>
瞬时对象转为持久对象：<br>
通过 <code>Session</code> 的 <code>update()</code>,<code>saveOrUpdate() </code>和 <code>lock()</code> 等方法，把脱管对象变为持久对象。<br>
<img src="/images/hibernate.jpg" alt=""></p>
<h2 id="JPA-实体生命周期有四种状态">JPA 实体生命周期有四种状态</h2>
<p><code>New</code>：瞬时对象，尚未有id，还未和<code>Persistence Context</code>建立关联的对象。<br>
<code>Managed</code>：持久化受管对象，有id值，已经和<code>Persistence Context</code>建立了关联的对象。<br>
<code>Datached</code>：游离态离线对象，有id值，但没有和<code>Persistence Context</code>建立关联的对象。<br>
<code>Removed</code>：删除的对象，有id值，尚且和<code>Persistence Context</code>有关联，但是已经准备好从数据库中删除。<br>
<code>Managed</code>状态下的数据保存，更新以及删除数据下的<code>Removed</code>状态，数据都不会立即更新到数据库，只有当你事务提交或者<code>em.flush()</code>，才会立即更新到数据库。<br>
<code>Datached</code>的状态，可以调用<code>em.merge()</code>方法，这个方法会根据实体类的id来更新数据库数据，这时实体类变成了<code>Managed</code>状态。<br>
四种状态总结：</p>
<p>状态名                      作为java对象存在                    在实体管理器中存在                      在数据库存在</p>
<p>New                             yes                                 no                                  no</p>
<p>Managed                         yes                                 yes                                 yes</p>
<p>Detached                        no                                  no                                  no</p>
<p>Removed                         yes                                 yes                                 no</p>
<h2 id="解决办法">解决办法</h2>
<ol>
<li>注入EntityManager</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PersistenceContext</span></span><br><span class="line">EntityManager entityManager;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>临时赋值后,detch对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">entityManager.detach(xxx);</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Video&gt; living = videos.getContent().stream().filter(x-&gt;x.getIsLive()!=<span class="keyword">null</span>).filter(x-&gt;x.getIsLive()==<span class="number">2</span>).filter(x-&gt;x.getLiveTime().compareTo(<span class="keyword">new</span> Date())&gt;<span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">           living.forEach(e-&gt;&#123;</span><br><span class="line">               e.setHd(<span class="string">""</span>);</span><br><span class="line">               e.setSd(<span class="string">""</span>);</span><br><span class="line">               e.setUltraClear(<span class="string">""</span>);</span><br><span class="line">               entityManager.detach(e);</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="detach-方法">detach()方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method</span><br><span class="line">javax.persistence.EntityManager</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Object entity</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<p>Remove the given entity from the persistence context, causing a managed entity to become detached. Unflushed changes made to the entity if any (including removal of the entity), will not be synchronized to the database. Entities which previously referenced the detached entity will continue to reference it.<br>
Parameters:<br>
entity - entity instance<br>
Throws:<br>
IllegalArgumentException - if the instance is not an entity<br>
Since:<br>
JPA 2.0</p>
<p><a href="https://www.cnblogs.com/0201zcr/p/6580192.html" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx域名转发</title>
    <url>/2018/12/27/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="nginx-conf配置文件">nginx.conf配置文件</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> For more information on configuration, see:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span></span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        listen       [::]:80;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Settings <span class="keyword">for</span> a TLS enabled server.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    server &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        listen       443 ssl http2 default_server;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        listen       [::]:443 ssl http2 default_server;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        server_name  _;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        root         /usr/share/nginx/html;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_certificate <span class="string">"/etc/pki/nginx/server.crt"</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_certificate_key <span class="string">"/etc/pki/nginx/private/server.key"</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_session_timeout  10m;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_ciphers HIGH:!aNULL:!MD5;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        <span class="comment"># Load configuration files for the default server block.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">        include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        location / &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        &#125;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        error_page 404 /404.html;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            location = /40x.html &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        &#125;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            location = /50x.html &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        &#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>include /etc/nginx/conf.d/*.conf</code>; //引入/etc/nginx/conf.d/下的所有.conf子配置文件 注意这条很重要，因为在默认配置中没有server段的配置，而一般都是将server的配置放在/etc/nginx/conf.d/目录下。<br>
正常情况下http段配置结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">      ...</span><br><span class="line">    server &#123;</span><br><span class="line">          ...</span><br><span class="line">        location [PATTERN]  &#123;</span><br><span class="line">               ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN]  &#123;</span><br><span class="line">              ...</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  server &#123;</span><br><span class="line">         ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nginx的相关命令和服务启动加载<br>
<code>nginx  -s  reload </code> ：重新加载nginx的配置文件；</p>
<p><code>nginx  -t</code>：检查配置文件语法是否有问题；</p>
<p>Nginx服务启动、停止、重新加载</p>
<p>#service nginx start  | stop | reload</p>
<p>#/etc/init.d/nginx  start | stop | reload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sites-enabled</span><br><span class="line">这里面的配置文件其实就是sites-available里面的配置文件的软</span><br><span class="line">连接,但是由于nginx.conf默认包含的是这个文件夹,所以我们在</span><br><span class="line">sites-available里面建立了新的站点之后,还要建立个软连接到sites-enabled里面才行</span><br><span class="line"></span><br><span class="line">sites-available</span><br><span class="line">这里是我们的虚拟主机的目录，我们在在这里面可以创建多个虚拟主机.</span><br><span class="line">## </span><br><span class="line">在conf.d下面配置我的两个配置文件</span><br><span class="line">aaa.conf</span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">upstream gooneserver  &#123;</span><br><span class="line">    server 127.0.0.1:8580;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	listen       80 default_server;</span><br><span class="line">	server_name  www.rizin.fun rizin.fun;</span><br><span class="line"></span><br><span class="line">	access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;goone.access.log  main;</span><br><span class="line">	error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;goone.error.log;</span><br><span class="line"></span><br><span class="line">        root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">	index  index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">	## send request back to apache ##</span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">		proxy_pass  http:&#x2F;&#x2F;gooneserver;</span><br><span class="line"></span><br><span class="line">		#Proxy Settings</span><br><span class="line">		proxy_redirect     off;</span><br><span class="line">		proxy_set_header   Host             $host;</span><br><span class="line">		proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">		proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">		proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">		proxy_max_temp_file_size 0;</span><br><span class="line">		proxy_connect_timeout      90;</span><br><span class="line">		proxy_send_timeout         90;</span><br><span class="line">		proxy_read_timeout         90;</span><br><span class="line">		proxy_buffer_size          4k;</span><br><span class="line">		proxy_buffers              4 32k;</span><br><span class="line">		proxy_busy_buffers_size    64k;</span><br><span class="line">		proxy_temp_file_write_size 64k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yyy.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream gooneadminserver  &#123;</span><br><span class="line">    server 127.0.0.1:8581;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	listen       80;</span><br><span class="line">	server_name  admin.rizin.fun;</span><br><span class="line"></span><br><span class="line">	access_log  /var/log/nginx/admin.goone.access.log  main;</span><br><span class="line">	error_log  /var/log/nginx/admin.goone.error.log;</span><br><span class="line"></span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line">	index  index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line"><span class="meta">	#</span><span class="bash"><span class="comment"># send request back to apache ##</span></span></span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass  http://gooneadminserver;</span><br><span class="line"></span><br><span class="line"><span class="meta">		#</span><span class="bash">Proxy Settings</span></span><br><span class="line">		proxy_redirect     off;</span><br><span class="line">		proxy_set_header   Host             $host;</span><br><span class="line">		proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">		proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">		proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">		proxy_max_temp_file_size 0;</span><br><span class="line">		proxy_connect_timeout      90;</span><br><span class="line">		proxy_send_timeout         90;</span><br><span class="line">		proxy_read_timeout         90;</span><br><span class="line">		proxy_buffer_size          4k;</span><br><span class="line">		proxy_buffers              4 32k;</span><br><span class="line">		proxy_busy_buffers_size    64k;</span><br><span class="line">		proxy_temp_file_write_size 64k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot Junit Restful Api 测试用例</title>
    <url>/2018/10/27/springbootjunittest/</url>
    <content><![CDATA[<h2 id="Controller的单元测试">Controller的单元测试</h2>
<h3 id="第一种使用模拟环境进行测试">第一种使用模拟环境进行测试</h3>
<h4 id="原理">原理</h4>
<p>使用<code>MockMvc</code>发起请求，然后执行API中相应的代码，在执行的过程中使mock模拟底层数据的返回，最后结果验证。<br>
<code>Spring</code>测试框架提供<code>MockMvc</code>对象，可以在不需要客户端-服务端请求的情况下进行MVC测试，完全在服务端这边就可以执行<code>Controller</code>的请求，跟启动了测试服务器一样。<br>
测试开始之前需要建立测试环境，<code>setup</code>方法被<code>@Before</code>修饰。通过<code>MockMvcBuilders</code>工具，使用<code>WebApplicationContext</code>对象作为参数，创建一个<code>MockMvc</code>对象。</p>
<a id="more"></a>
<p>MockMvc对象提供一组工具函数用来执行assert判断，都是针对web请求的判断。这组工具的使用方式是函数的链式调用，允许程序员将多个测试用例链接在一起，并进行多个判断。通常我们会用到下面的一些工具函数：<br>
<code>perform(get(...))</code>建立web请求。通过<code>MockMvcRequestBuilder</code>执行GET请求。post、delete分别对应<code>POST</code>、<code>DELETE</code>请求<br>
<code>andExpect(...)可以在perform(...)</code>函数调用后多次调用，表示对多个条件的判断，这个函数的参数类型是<code>ResultMatcher</code>接口，在<code>MockMvcResultMatchers</code>这这个类中提供了很多返回ResultMatcher接口的工具函数。这个函数使得可以检测同一个web请求的多个方面，包括HTTP响应状态码（response status），响应的内容类型（content type），会话中存放的值，检验重定向、model或者header的内容等等。这里需要通过第三方库json-path检测JSON格式的响应数据：检查json数据包含正确的元素类型和对应的值，例如<code>jsonPath(&quot;$.name&quot;).value(&quot;中文测试&quot;)</code>用于检查在根目录下有一个名为name的节点，并且该节点对应的值是“中文测试”。</p>
<h4 id="MockMvc对象的引入的两种方式">MockMvc对象的引入的两种方式</h4>
<p>1.测试类上添加<code>@AutoConfigureMockMvc</code>注解，该注解表示启动测试的时候自动注入<code> MockMvc</code>,然后直接<code>@Autowired</code>注入<code>MockMvc</code>对象,示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureMockMvc</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userMapping</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String JSON =</span><br><span class="line">                <span class="string">"&#123;\"nickName\":\"岗村一泽\",\"lastName\":\"岗村\",\"firstName\":\"一泽\",\"email\":\"gangcunyiza@gmail.com\",\"password\":\"12345678\",\"jpFirstName\":\"一泽\",\"jpLastName\":\"岗村\",\"address1\":\"大阪\",\"address2\":\"台東区東上野３丁目\",\"address3\":\"１９番６号\",\"phone\":\"2014561\",\"postalCode\":\"1100112\"&#125;"</span>;</span><br><span class="line">        Mockito.when(userService.findByEmailAndStatus(<span class="string">"gangcunyiza@gmail.com.com"</span>,<span class="number">1</span>)).thenReturn(user);</span><br><span class="line">        Mockito.when(userRepository.findByNickNameAndStatus(<span class="string">"岗村一泽"</span>,<span class="number">1</span>)).thenReturn(user);</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/registe"</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON).content(JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.使用<code>MockMvcBuilder</code>构建<code>MockMvc</code>对象,示例代码如下：、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">UserControllerTest4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext web;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupMockMvc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(web).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用法">用法</h4>
<p>1.<code>MockMvcBuilders.webAppContextSetup(WebApplicationContext context)</code>：指定<code>WebApplicationContext</code>，将会从该上下文获取相应的控制器并得到相应的<code>MockMvc</code>;<br>
2.部分方法说明<br>
<code>perform</code>：执行一个<code>RequestBuilder</code>请求，会自动执行<code>SpringMVC</code>的流程并映射到相应的控制器执行处理;<br>
<code>andExpec</code>t：添加<code>ResultMatcher</code>验证规则，验证控制器执行完成后结果是否正确;<br>
<code>andDo</code>：添加<code>ResultHandler</code>结果处理器，比如调试时打印结果到控制台;<br>
<code>andReturn</code>：最后返回相应的<code>MvcResult</code>；然后进行自定义验证/进行下一步的异步处理;<br>
3.<code>MockMvc</code> 测试整个流程程说明：<br>
1.<code>mockMvc.perform</code>执行一个请求；<br>
2.<code>MockMvcRequestBuilders.get(&quot;/1/2&quot;)</code>构造一个请求<br>
3.<code>ResultActions.andExpect</code>添加执行完成后的断言<br>
4.<code>ResultActions.andDo</code>添加一个结果处理器，表示要对结果做点什么事情，比如此处使用<code>MockMvcResultHandlers.print()</code>输出整个响应结果信息。<br>
5.<code>ResultActions.andReturn</code>表示执行完成后返回相应的结果。<br>
4.传参</p>
<ul>
<li>路径请求</li>
</ul>
<p>mockMvc.perform(MockMvcRequestBuilders<br>
.请求方式(“url/{path}”,参数值)</p>
<ul>
<li>表单请求</li>
</ul>
<p>mockMvc.perform(MockMvcRequestBuilders<br>
.请求方式(“url”).param(“键”,“值”).contentType(MediaType.APPLICATION_FORM_URLENCODED)</p>
<ul>
<li>JSON请求</li>
</ul>
<p>mockMvc.perform(MockMvcRequestBuilders<br>
.请求方式，一般为POST(“url”).content(JSONObject.toJSONString(map)).contentType(.contentType(MediaType.APPLICATION_JSON))</p>
<p>测试过程如下：<br>
1、准备测试环境<br>
2、通过<code>MockMvc</code>执行请求<br>
3.添加验证断言<br>
4.添加结果处理器<br>
5.得到MvcResult进行自定义断言/进行下一步的异步请求<br>
6.卸载测试环境</p>
<h3 id="第二种使用真实Web环境进行测试">第二种使用真实Web环境进行测试</h3>
<p>在@SpringBootTest注解中设置属性 webEnvironment = WebEnvironment.RANDOM_PORT,每次运行的时候会随机选择一个可用端口。我们也可以还使用 @LoalServerPort注解用于本地端口号。下面是测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">webEnvironment</span> </span>= SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerTest3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userMapping</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setNickName(<span class="string">"pj_pj"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"12345678"</span>);</span><br><span class="line">        ResponseEntity&lt;String&gt; responseEntity = testRestTemplate.postForEntity(<span class="string">"/user"</span>, user, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"Result: "</span>+responseEntity.getBody());</span><br><span class="line">        System.out.println(<span class="string">"状态码: "</span>+responseEntity.getStatusCodeValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中有一个关键的类——TestRestTemplate, TestRestTemplate是Spring的RestTemplate的一种替代品，可用于集成测试，更RestTemplate的使用功能方法类似，一般用于真实web环境测试中，关于该类更加详细的用法参考<a href="https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-test-scope-dependencies" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="常用注解介绍">常用注解介绍</h2>
<p><code>@SpringBootTest</code>是<code>SpringBoot</code>的一个用于测试的注解，通过<code>SpringApplication</code>在测试中创建<code>ApplicationContext</code>。<br>
<code>@AutoConfigureMockMvc</code>是用于自动配置MockMvc。<br>
<code>@RunWith在JUnit</code>中有很多个<code>Runner</code>，他们负责调用你的测试代码，每一个<code>Runner</code>都有各自的特殊功能，你要根据需要选择不同的Runner来运行你的测试代码。<br>
<code>@Before</code>在每个测试方法前执行，一般用来初始化方法。<br>
<code>@After</code>在每个测试方法后执行，在方法执行完成后要做的事情。</p>
<h2 id="主要代码">主要代码</h2>
<p>引入测试jar包</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureMockMvc</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span> <span class="comment">//测试前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//先注册一个user对象</span></span><br><span class="line">        String JSON =</span><br><span class="line">                <span class="string">"&#123;\"nickName\":\"岗村一泽\",\"lastName\":\"岗村\",\"firstName\":\"一泽\",\"email\":\"gangcunyiza@gmail.com\",\"password\":\"12345678\",\"jpFirstName\":\"一泽\",\"jpLastName\":\"岗村\"&#125;"</span>;</span><br><span class="line">        Mockito.when(userService.findByEmailAndStatus(<span class="string">"gangcunyiza@gmail.com.com"</span>,<span class="number">1</span>)).thenReturn(user);</span><br><span class="line">        Mockito.when(userRepository.findByNickNameAndStatus(<span class="string">"岗村一泽"</span>,<span class="number">1</span>)).thenReturn(user);</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/registe"</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON).content(JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span> <span class="comment">//测试后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String JSON = <span class="string">"&#123;\"email\":\"gangcunyiza@gmail.com.com\",\"password\":\"12345678\"&#125;"</span>;</span><br><span class="line">                mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/login"</span>)</span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON).content(JSON)</span><br><span class="line">                        .contentType(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())<span class="comment">//断言请求状态</span></span><br><span class="line">                        .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果是只想关注Web层而不是启动完整的<code>ApplicationContext</code>,可以考虑使用<code>@WebMvcTest</code>注解，该注解不能与@<code>SpringBootTest</code>搭配使用，而且它只关注Web层面，至于涉及到数据层的时候，需要引入相关依赖，关于这个注解更多的介绍请参阅<a href="https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="单元测试回滚">单元测试回滚</h2>
<p>单元测试的时候，如果不想造成垃圾数据，可以开启事务功能，在方法或类头部添加<code>@Transactional</code>注解即可，在官方文档中对此也有说明。如果你想关闭回滚，只要加上 @Rollback(false)注解即可。<br>
还有一种情况需要注意，就是如果你使用的数据库是MySQL,有时候会发现加了注解 @Transactionl也不会回滚，那么你就要查看一下你的默认引擎是不是InnoDB,如果不是就要改成 InnoDB。<br>
MyISAM 与 InnoDB是mysql目前比较常用的两个数据库引擎，MyISAM与InnoDB的主要的不同点在于性能和事务控制上，这里简单介绍下两者的区别与转换方法：</p>
<p>MyISAM： MyISAM是MySQL5.5之前版本默认的数据库存储引擎，MyISAM提供高速存储和检索，以及全文搜索能力，适合数据仓库等查询频繁的应用，但不支持事务和外键，不能在表损坏后恢复数据<br>
InnoDB: InnoDB是MySQL5.5版本的默认数据库存储引擎，InnoDB具有提交，回滚和崩溃恢复能力的事务安全，支持事务和外键，比起MyISAM,InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署推荐</title>
    <url>/2018/07/28/hexo%E9%83%A8%E7%BD%B2%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h2 id="一个博客为什么要建两个仓库">一个博客为什么要建两个仓库</h2>
<p>之前我的博客就一个仓库，还是公有的，那么问题来了，我发布文章部署之后所有人都可以看我的源码及配置文件😟。这是绝对不能允许的，并不是小编我太小气，就是怕有些投机取巧不劳而获的人直接copy我的源码发表，岂不是便宜了他，这样的人大家都不喜欢吧？好了，废话少说，开始步入正题😀。</p>
<a id="more"></a>
<h2 id="操作步骤">操作步骤</h2>
<p><a href="http://xn--jiangfumei-0b4pt84bvza161dhjholcjyqxlqlos7vf640a5x7c.github.io" target="_blank" rel="noopener">比如原来我的博客仓库就是jiangfumei.github.io</a>,这个仓库是公有的。我需要在github上再新建一个私有仓库，我新建的仓库名字是MyBlog,然后本地clone下来，现在为止，小编还是建议把原来的博客仓库备份一下，保证万无一失吗😝。<br>
然后在公有仓库jiangfumei.github.io根目录下的_config.yml的deploy配置中增加你的仓库地址，如下图：<br>
<img src="/images/blogdeploy.png" alt=""><br>
在jiangfumei.github.io根目录下<code>hexo g -d</code>即可。<br>
登入github网页，查看私有仓库公有仓库发现已经和你期望的那样啦！<br>
<img src="/images/blogcommon.png" alt=""><br>
<img src="/images/blogprivate.png" alt=""></p>
<h2 id="问题及建议">问题及建议</h2>
<p>在实践中，我碰到每次<code>hexo g -d</code>公有库生成的目录结构竟然和私有库一样，那到底是什么原因昵？原来是_congig.yml的public_dir配置错误，开始配的是./public_。改为<code>public</code>.<br>
其次，小编建议选择Netlify为托管平台。Netlify是一家国外的静态网站的托管平台，提供免费的https，自动化部署和升级，可以监控GitHub、GitLab或者Bitbucket做到自动更新发布。集成过程网上到处都是，这里不再叙述。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化之DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</title>
    <url>/2018/07/12/serlize/</url>
    <content><![CDATA[<h2 id="Java-反序列化">Java 反序列化</h2>
<p><code>private static final ObjectMapper mapper = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</code><br>
<code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>属性默认为true开启状态，当属性为true时，表示在反序列化时遇到未知属性(属性没有对应的类属性来映射,并且没有任何setter或handler来处理这样的属性)时会引起结果失败(通过抛JsonMappingException异<br>
忽略不需要的字体<br>
有时候，返回的JSON字符串中含有我们并不需要的字段，那么当对应的实体类中不含有该字段时，会抛出一个异常，告诉你有些字段没有在实体类中找到。解决办法很简单，在声明ObjectMapper之后，加上下述代码：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, ExProduct&gt; <span class="title">getExProduct</span><span class="params">(RedisService redisService)</span> </span>&#123;</span><br><span class="line">       Map&lt;String, String&gt; productJson = redisService.getMap(<span class="string">"HRY:EXCHANGE:PRODUCT"</span>);</span><br><span class="line">       Map&lt;String, ExProduct&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       productJson.forEach((k, v) -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ExProduct product = mapper.readValue(v, ExProduct<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">               map.put(k, product);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充">补充</h4>
<p>对于结构固定的JSON，使用ObjectMapper结合某个预先定义的实体类型可以非常方便地完成反序列化工作，比如对下面这样的JSON：</p>
<p>GET /person/1</p>
<p>{<br>
“id”: “1”,<br>
“name”: “dm_vincent”,<br>
“age”: “28”<br>
}</p>
<p>结合一个实体类型，可以很轻松的完成反序列化工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getEntity</span><span class="params">(String jsonString, Class&lt;T&gt; prototype)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (T) objectMapper.readValue(jsonString, prototype);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>但是在某些支持一次性获取多条记录的API中，就出现问题了。比如拥有下面这种格式的API：</p>
<p>GET /person/1,2,3</p>
<p>{<br>
“dm_vincent”: {<br>
“id”: “1”,<br>
“name”: “dm_vincent”,<br>
“age”: “28”<br>
},<br>
“dm_vincent2”: {<br>
“id”: “2”,<br>
“name”: “dm_vincent2”,<br>
“age”: “29”<br>
},<br>
“dm_vincent3”: {<br>
“id”: “3”,<br>
“name”: “dm_vincent3”,<br>
“age”: “30”<br>
}<br>
}<br>
虽然需要获取的实体类型还是那个Person类，可是这个时候就不像上面那样简单明了了。比如下面这段代码在反序列化的时候会出现问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Person&gt; persons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的意图是明确的，将返回的多个Person实体对象放到一个Map结构中。但是问题就在于返回的JSON中的keys是不固定的(比如上述JSON中的keys是人名)，这导致反序列化失败。毕竟默认配置下的ObjectMapper也没有聪明到这种程度，能够猜测你是想要将多个实体放到Map中。</p>
<p>正确的做法之一是使用ObjectMapper的readTree方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">EntityWrapper&lt;T&gt; <span class="title">getEntityWrapper</span><span class="params">(String jsonString, Class&lt;T&gt; prototype)</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    EntityWrapper&lt;T&gt; wrapper = <span class="keyword">new</span> EntityWrapper&lt;T&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      JsonNode root = objectMapper.readTree(jsonString);</span><br><span class="line">      Iterator&lt;Entry&lt;String, JsonNode&gt;&gt; elements = root.fields();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (elements.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, JsonNode&gt; node = elements.next();</span><br><span class="line">        String key = node.getKey();</span><br><span class="line">        T element = objectMapper.readValue(node.getValue().toString(), prototype);</span><br><span class="line">        wrapper.addEntry(key, element);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>简单解释一下上述代码：<br>
使用<code>root.field()</code>方法能够得到返回的JSON中的所有key-value对。<br>
然后循环提取某个键值对的key和value，对于value我们可以直接使用之前的策略进行反序列化，因为这部分的结构也是固定的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析Java的序列化与反序列化</title>
    <url>/2018/02/08/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="JavaAPI中的定义">JavaAPI中的定义:</h2>
<p><code>public interface Serializable</code><br>
类通过实现 <code>java.io.Serializable</code> 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。<br>
要允许不可序列化类的子类型序列化，可以假定该子类型负责保存和恢复超类型的公用 <code>(public)</code>. 受保护的 <code>(protected)</code> 和（如果可访问）包 <code>(package)</code> 字段的状态。仅在子类型扩展的类有一个可访问的无参数构造方法来初始化该类的状态时，才可以假定子类型有此职责。如果不是这种情况，则声明一个类为可序列化类是错误的。该错误将在运行时检测到。</p>
<a id="more"></a>
<p>在反序列化过程中，将使用该类的公用或受保护的无参数构造方法初始化不可序列化类的字段。可序列化的子类必须能够访问无参数构造方法。可序列化子类的字段将从该流中恢复。<br>
当遍历一个图形时，可能会遇到不支持 Serializable 接口的对象。在此情况下，将抛出 <code>NotSerializableException</code>，并将标识不可序列化对象的类。<br>
在序列化和反序列化过程中需要特殊处理的类必须使用下列准确签名来实现特殊方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></table></figure>
<p><code>writeObject</code> 方法负责写入特定类的对象的状态，以便相应的 readObject 方法可以恢复它。通过调用 <code>out.defaultWriteObject</code> 可以调用保存 <code>Object</code> 的字段的默认机制。该方法本身不需要涉及属于其超类或子类的状态。通过使用 <code>writeObject</code> 方法或使用 <code>DataOutput</code> 支持的用于基本数据类型的方法将各个字段写入 <code>ObjectOutputStream</code>，状态可以被保存。</p>
<!-- more -->
<p><code>readObject</code> 方法负责从流中读取并恢复类字段。它可以调用 <code>in.defaultReadObject</code> 来调用默认机制，以恢复对象的非静态和非瞬态字段。<code>defaultReadObject </code>方法使用流中的信息来分配流中通过当前对象中相应指定字段保存的对象的字段。这用于处理类演化后需要添加新字段的情形。该方法本身不需要涉及属于其超类或子类的状态。通过使用 writeObject 方法或使用 <code>DataOutput</code> 支持的用于基本数据类型的方法将各个字段写入 <code>ObjectOutputStream</code>，状态可以被保存。</p>
<p>在序列化流不列出给定类作为将被反序列化对象的超类的情况下，<code>readObjectNoData</code> 方法负责初始化特定类的对象状态。这在接收方使用的反序列化实例类的版本不同于发送方，并且接收者版本扩展的类不是发送者版本扩展的类时发生。在序列化流已经被篡改时也将发生；因此，不管源流是“敌意的”还是不完整的，<code>readObjectNoData</code> 方法都可以用来正确地初始化反序列化的对象。</p>
<p>将对象写入流时需要指定要使用的替代对象的可序列化类，应使用准确的签名来实现此特殊方法：</p>
<p><code>ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;</code></p>
<p>此 <code>writeReplace</code> 方法将由序列化调用，前提是如果此方法存在，而且它可以通过被序列化对象的类中定义的一个方法访问。因此，该方法可以拥有私有 <code>(private)</code>. 受保护的 (protected) 和包私有 <code>(package-private)</code> 访问。子类对此方法的访问遵循 java 访问规则。</p>
<p>在从流中读取类的一个实例时需要指定替代的类应使用的准确签名来实现此特殊方法。</p>
<p><code>ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;</code></p>
<p>此 <code>readResolve</code> 方法遵循与 <code>writeReplace</code> 相同的调用规则和访问规则。</p>
<p>序列化运行时使用一个称为 <code>serialVersionUID</code> 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 <code>serialVersionUID</code> 与对应的发送者的类的版本号不同，则反序列化将会导致 <code>InvalidClassException</code>。可序列化类可以通过声明名为 “<code>serialVersionUID</code>” 的字段（该字段必须是静态 <code>(static)</code>. 最终 <code>(final)</code> 的 long 型字段）显式声明其自己的 <code>serialVersionUID</code>：</p>
<p><code>ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;</code></p>
<p>如果可序列化类未显式声明 <code>serialVersionUID</code>，则序列化运行时将基于该类的各个方面计算该类的默认 <code>serialVersionUID </code>值，如“Java™ 对象序列化规范”中所述。不过，强烈建议 所有可序列化类都显式声明 <code>serialVersionUID</code> 值，原因是计算默认的 <code>serialVersionUID</code> 对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别，这样在反序列化过程中可能会导致意外的 <code>InvalidClassException</code>。因此，为保证 <code>serialVersionUID</code> 值跨不同 java 编译器实现的一致性，序列化类必须声明一个明确的 <code>serialVersionUID</code> 值。还强烈建议使用 <code>private</code> 修饰符显示声明 <code>serialVersionUID</code>（如果可能），原因是这种声明仅应用于直接声明类 – <code>serialVersionUID</code> 字段作为继承成员没有用处。数组类不能声明一个明确的 <code>serialVersionUID</code>，因此它们总是具有默认的计算值，但是数组类没有匹配 <code>serialVersionUID</code> 值的要求。<br>
从以下版本开始：<br>
<code>JDK1.1</code></p>
<h1>深入分析Java的序列化与反序列化</h1>
<p>序列化是一种对象持久化的手段。普遍应用在网络传输. RMI等场景中。本文通过分析ArrayList的序列化来介绍Java序列化的相关内容。主要涉及到以下几个问题：</p>
<ul>
<li>
<p>怎么实现Java的序列化</p>
</li>
<li>
<p>为什么实现了java.io.Serializable接口才能被序列化</p>
</li>
<li>
<p>transient的作用是什么</p>
</li>
<li>
<p>怎么自定义序列化策略</p>
</li>
<li>
<p>自定义的序列化策略是如何被调用的</p>
</li>
<li>
<p>ArrayList对序列化的实现有什么好处</p>
</li>
</ul>
<h2 id="Java对象的序列化">Java对象的序列化</h2>
<p>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。</p>
<p>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。</p>
<p>除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。</p>
<h2 id="如何对Java对象进行序列化与反序列化">如何对Java对象进行序列化与反序列化</h2>
<p>在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。这里先来一段代码：</p>
<p>code 1 创建一个User类，用于序列化及反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hollis;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hollis on 16/2/2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", gender="</span> + gender +</span><br><span class="line">                <span class="string">", birthday="</span> + birthday +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>code 2 对User进行序列化及反序列化的Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hollis;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hollis on 16/2/2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Initializes The Object</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"hollis"</span>);</span><br><span class="line">        user.setGender(<span class="string">"male"</span>);</span><br><span class="line">        user.setAge(<span class="number">23</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Write Obj to File</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Read Obj from File</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User newUser = (User) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(ois);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User&#123;name=<span class="string">'hollis'</span>, age=<span class="number">23</span>, gender=male, birthday=Tue Feb <span class="number">02</span> <span class="number">17</span>:<span class="number">37</span>:<span class="number">38</span> CST <span class="number">2016</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'hollis'</span>, age=<span class="number">23</span>, gender=<span class="keyword">null</span>, birthday=Tue Feb <span class="number">02</span> <span class="number">17</span>:<span class="number">37</span>:<span class="number">38</span> CST <span class="number">2016</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="序列化及反序列化相关知识">序列化及反序列化相关知识</h2>
<ol>
<li>
<p>在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。</p>
</li>
<li>
<p>通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化</p>
</li>
<li>
<p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）</p>
</li>
<li>
<p>序列化并不保存静态变量。</p>
</li>
<li>
<p>要想将父类对象也序列化，就需要让父类也实现Serializable 接口。</p>
</li>
<li>
<p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
</li>
<li>
<p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p>
</li>
</ol>
<h2 id="ArrayList的序列化">ArrayList的序列化</h2>
<p>在介绍ArrayList序列化之前，先来考虑一个问题：</p>
<p>如何自定义的序列化和反序列化策略</p>
<p>带着这个问题，我们来看java.util.ArrayList的源码</p>
<p>code 3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔者省略了其他成员变量，从上面的代码中可以知道<code>ArrayList</code>实现了<code>java.io.Serializable</code>接口，那么我们就可以对它进行序列化及反序列化。因为<code>elementData</code>是<code>transient</code>的，所以我们认为这个成员变量不会被序列化而保留下来。我们写一个Demo，验证一下我们的想法：</p>
<p>code 4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        stringList.add(<span class="string">"hello"</span>);</span><br><span class="line">        stringList.add(<span class="string">"world"</span>);</span><br><span class="line">        stringList.add(<span class="string">"hollis"</span>);</span><br><span class="line">        stringList.add(<span class="string">"chuang"</span>);</span><br><span class="line">        System.out.println(<span class="string">"init StringList"</span> + stringList);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"stringlist"</span>));</span><br><span class="line">        objectOutputStream.writeObject(stringList);</span><br><span class="line"></span><br><span class="line">        IOUtils.close(objectOutputStream);</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"stringlist"</span>);</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        List&lt;String&gt; newStringList = (List&lt;String&gt;)objectInputStream.readObject();</span><br><span class="line">        IOUtils.close(objectInputStream);</span><br><span class="line">        <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"new StringList"</span> + newStringList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init StringList[hello, world, hollis, chuang]</span><br><span class="line">new StringList[hello, world, hollis, chuang]</span><br></pre></td></tr></table></figure>
<p>了解<code>ArrayList</code>的人都知道，<code>ArrayList</code>底层是通过数组实现的。那么数组<code>elementData</code>其实就是用来保存列表中的元素的。通过该属性的声明方式我们知道，他是无法通过序列化持久化下来的。那么为什么 <strong>code 4</strong> 的结果却通过序列化和反序列化把List中的元素保留下来了呢？</p>
<h3 id="writeObject和readObject方法">writeObject和readObject方法</h3>
<p>在ArrayList中定义了来个方法： writeObject和readObject。</p>
<p>这里先给出结论:</p>
<p>在序列化过程中，如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。</p>
<p>如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。</p>
<p>用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。</p>
<p>来看一下这两个方法的具体实现：</p>
<p>code 5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>code 6</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么为什么ArrayList要用这种方式来实现序列化呢？</p>
<h3 id="why-transient">why transient</h3>
<p>ArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设置为transient。</p>
<h3 id="why-writeObject-and-readObject">why writeObject and readObject</h3>
<p>前面说过，为了防止一个包含大量空对象的数组被序列化，为了优化存储，所以，ArrayList使用transient来声明elementData。 但是，作为一个集合，在序列化过程中还必须保证其中的元素可以被持久化下来，所以，通过重写writeObject 和 readObject方法的方式把其中的元素保留下来。</p>
<p>writeObject方法把elementData数组中的元素遍历的保存到输出流（ObjectOutputStream）中。</p>
<p>readObject方法从输入流（ObjectInputStream）中读出对象并保存赋值到elementData数组中。</p>
<p>至此，我们先试着来回答刚刚提出的问题：</p>
<p>如何自定义的序列化和反序列化策略</p>
<p>答：可以通过在被序列化的类中增加writeObject 和 readObject方法。那么问题又来了：</p>
<p>虽然ArrayList中写了writeObject 和 readObject 方法，但是这两个方法并没有显示的被调用啊。</p>
<p>那么如果一个类中包含writeObject 和 readObject 方法，那么这两个方法是怎么被调用的呢?</p>
<h2 id="ObjectOutputStream">ObjectOutputStream</h2>
<p>从code 4中，我们可以看出，对象的序列化过程通过ObjectOutputStream和ObjectInputputStream来实现的，那么带着刚刚的问题，我们来分析一下ArrayList中的writeObject 和 readObject 方法到底是如何被调用的呢？</p>
<p>为了节省篇幅，这里给出ObjectOutputStream的writeObject的调用栈：</p>
<p>writeObject —&gt; writeObject0 —&gt;writeOrdinaryObject—&gt;writeSerialData—&gt;invokeWriteObject</p>
<p>这里看一下invokeWriteObject：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWriteObject</span><span class="params">(Object obj, ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, UnsupportedOperationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (writeObjectMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writeObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; out &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable th = ex.getTargetException();</span><br><span class="line">                <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    throwMiscException(th);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="comment">// should not occur, as access checks have been suppressed</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中writeObjectMethod.invoke(obj, new Object[]{ out });是关键，通过反射的方式调用writeObjectMethod方法。官方是这么解释这个writeObjectMethod的：</p>
<p>class-defined writeObject method, or null if none</p>
<p>在我们的例子中，这个方法就是我们在ArrayList中定义的writeObject方法。通过反射的方式被调用了。</p>
<p>至此，我们先试着来回答刚刚提出的问题：</p>
<p>如果一个类中包含writeObject 和 readObject 方法，那么这两个方法是怎么被调用的?</p>
<p>答：在使用ObjectOutputStream的writeObject方法和ObjectInputStream的readObject方法时，会通过反射的方式调用。</p>
<p>至此，我们已经介绍完了ArrayList的序列化方式。那么，不知道有没有人提出这样的疑问：</p>
<p>Serializable明明就是一个空的接口，它是怎么保证只有实现了该接口的方法才能进行序列化与反序列化的呢？</p>
<h3 id="Serializable接口的定义：">Serializable接口的定义：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读者可以尝试把 <strong>code 1</strong> 中的继承<code>Serializable</code>的代码去掉，再执行 <strong>code 2</strong> ，会抛出<code>java.io.NotSerializableException</code>。</p>
<p>其实这个问题也很好回答，我们再回到刚刚ObjectOutputStream的writeObject的调用栈：<br>
<font color='red'><br>
writeObject —&gt; writeObject0 —&gt;writeOrdinaryObject—&gt;writeSerialData—&gt;invokeWriteObject<br>
</font><br>
<code>writeObject0</code>方法中有这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        writeString((String) obj, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">        writeArray(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">        writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">        writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在进行序列化操作时，会判断要被序列化的类是否是Enum. Array和Serializable类型，如果不是则直接抛出<code>NotSerializableException</code>。</p>
<h2 id="总结">总结</h2>
<ol>
<li>
<p>如果一个类想被序列化，需要实现<code>Serializable</code>接口。否则将抛出<code>NotSerializableException</code>异常，这是因为，在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum. Array和Serializable类型其中的任何一种。</p>
</li>
<li>
<p>在变量声明前加上该关键字，可以阻止该变量被序列化到文件中。</p>
</li>
<li>
<p>在类中增加<code>writeObject</code> 和 <code>readObject</code> 方法可以实现自定义序列化策略</p>
</li>
</ol>
<blockquote>
<p>本文转载自<a href="http://www.hollischuang.com/archives/1140" target="_blank" rel="noopener">深入分析Java的序列化与反序列化</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
</search>
